## 1. 변수 선언하여 사용하기

```java
public class Variable1 {
	public static void main(String[] args) {
		int level; //정수형 변수 level을 선언
		level = 10; //level 변수에 값 10을 대입
		System.out.println(level); //level 값 출력
	}
}
```

## 2. 변수 초기화하기

```java
public class Variable2 {
	public static void main(String[] args){
		int level = 10; //level 변수 선언과 동시에 값을 대입(초기화)
		System.out.println(level);
	}
}
```

## 3. 자료형이 다른 정수끼리 더하면 어떻게 될까요?

```java
public class IntegerVariable {
	public static void main(String[] args){
		short sVal = 10;
		byte bVal = 20;
		System.out.println(sVal+bVal); //int형으로 바뀌어 계산한다. 출력도 int형이 되어 출력
	}
}
```

## 4. 문자형 연습 1

```java
public class CharacterEx1 {
	public static void main(String[] args) {
		char ch1 = 'A';
		System.out.println(ch1);// 문자 A 출력
		System.out.println((int)ch1);// 문자에 해당하는 아스키코드 값 출력

		char ch2 = 66; // 정수 값 대입
		System.out.println(ch2); //정수 값에 해당하는 문자 출력 

		int ch3 = 67;
		System.out.println(ch3); //정수 값 출력
		System.out.println((char)ch3); //정수 값에 해당하는 문자 출력
	}
}
```

## 5. 문자형 연습 2

```java
public class CharacterEx2 {
	public static void main(String[] args) {
		char ch1 = '한';
		char ch2 = '\uD55C';
		
		System.out.println(ch1); //문자 '한' 출력
		System.out.println(ch2); // 유니코드 값 ￦uD55C에 해당하는 문자 출력
```

## 6. 문자형 연습 3

```java
public class CharacterEx3 {
	public static void main(String[] args) {
		int a = 65;
		int b = -66;

		char a2 = 65;
		//char b2 = -66; 문자형 변수에 음수를 넣으면 오류가 발생

		System.out.println((char)a); // 정수 값 65에 해당하는 문자 출력
		System.out.println((char)b); // 정수 값 -66에 해당하는 문자 출력
		System.out.println(a2); // 정수 값 65에 해당하는 문자 출력
	}
}
```

## 7. 실수형 연습 1

```java
public class DoubleEx1 {
	public static void main(String[] args) {
		double dnum = 3.14;
		float fnum = 3.14F; //F는 float형이라는 식별자

		System.out.println(dnum);
		System.out.println(fnum);
	}
}
```

## 8. 부동 소수점 방식의 오류

```java
public class DoubleEx2 {
	public static void main(String[] args) {
		double dnum = 1;

		for(int i = 0; i< 10000; i++{//for 문은 지정한 문장을 정해진 회수만큼 반복해서
			dnum = dnum+0.1;           //수행하는 반복문입니다.
		}
		System.out.println(dnum); //1에 0.1을 10000번 더했으므로 1001 일것 같지만
	}                           //오차가 난다. 하지만 약간의 오차를 감수하고라도
}                             //더넓은 범위의 실수 값을 표현하기 위해 부동소수점 방식을 사용한다.
```

## 9. 논리형 연습

```java
public class BooleanEx {
	public static void main(String[] args) {
		boolean isMarried = true; //boolean 변수를 선언하고 초기화
		System.out.println(isMarried);// boolean형 변수는 true나 false만 대입할수 있고 결과값도 true,false로 출력
	}
}
```

## 10. 자료형 추론

```java
public class TypeInference {
	public static void main(String[] args) {
		var i = 10; //int i=10 으로 컴파일
		var j = 10.0; // double j = 10.0으로 컴파일
		var str = "hello"; // String str = "hello" 컴파일됨

		System.out.println(i);
		System.out.println(j);
		System.out.println(str);

		str = "test"; //다른 문자열은 대입 가능
		//str = 3; str 변수는 String형으로 먼저 사용되었기 때문에 정수 값을 넣을수 없음
	}
}
```

## 11.  상수 사용하기

```java
public class Constant{
	public static void main(String[] args) {
		final int MAX_NUM = 100; //선언과 동시에 초기화
		final int MIN_NUM;
		
		MIN_NUM=0; //사용하기전에 초기화, JAVA는 초기화 하지않으면 오류 발생

		System.out.println(MAX_NUM);
		System.out.println(MIN_NUM);
	
		//MAX_NUM = 1000; // 오류발생, 상수는 값을 변경할 수 없음
	}
}

//상수를 사용하면 편리한 이유
if(count == 30){~}
while(i<30) {~}
=>
final int MAX_STUDENT_NUM = 35;
if(count == MAX_STUDENT_NUM) {~}
while(i < MAX_STUDENT_NUM) {~}
```

## 12. 묵시적 형 변환

```java
//묵시적 형 변환 = 자동으로 형 변환
//단, 바이트 크기가 작은 자료형에서 큰 자료형으로 대입하는 경우
public class ImplicitConvesion {
	public static void main(String[] args) {
		byte bNum = 10;
		int iNum = bNum; //byte형이 값이 int형 변수로 대입됨

		System.out.println(bNum);
		System.out.println(iNum);

		int iNum2 = 20;
		float fNum = iNum2; // int형 값이 float형 변수로 대입됨

		System.out.println(iNum);
		System.out.println(fNum);

		double dNum;
		dNum = fNum + iNum; //int형 값이 float형으로 바뀌어 계산후 double형 변수로 대입됨
		System.out.println(dNum);
	}
}
```

## 13. 명시적 형 변환

```java
//명시적 형 변환 = 수동으로 형 변환
//단, 바이트 크기가 작은 자료형에서 큰 자료형으로 대입하는 경우
public class ExplicitConversion {
	public static void main(String[] args) {
		double dNum1 = 1.2;
		float fNum2 = 0.9F;

		int iNum3 = (int)dNum1 + (int)fNum2; //두 실수가 각각 형 변환되어 더해짐
		int iNum4 = (int)(dNum1 + fNum2); //두 실수의 합이 먼저 계산되고 형변환됨
		System.out.println(iNum3); //실수에서 정수로 형변환시 뒤에 소수점 자리는 버려짐
		System.out.println(iNum4);
	}
}
```

## 14. 산술 연산자를 사용하여 총점과 평균 구하기

```java
public class OperationEx1 {
	public static void main(String[] args) {
		int mathScore = 90;
		int engScore = 70;
		
		int totalScore = mathScore + engScore; //총점 구하기
		System.out.println(totalScore);
		 
		double avgScore = totalScore / 2.0; //평균 구하기
		System.out.println(avgScore);
	}
}
```

## 15.증가 - 감소 연산자를 사용하여 값 연산하기

```java
public class OperationEx2 {
	public static void main(String[] args) {
		int gameScore = 150; //게임에서 획득한 점수는 150점
		
		int lastScore1 = ++gameScore; //gameScore에 1만큼 더한 값을 lastScore1에 대입
		System.out.println(lastScore1); //151
		//증감연산자 위치에 따라 값이 다르다. 뒤에 나오면 gameScore 값이 저장된후 값이 증가된다.
		int lastScore2 = --gameScore; //gameScore에서 1만큼 뺀 값을 lastScore2에 대입
		System.out.println(lastScore2); // 150
	}
}
```

## 16. 단락 회로 평가 실습하기

```java
public class OperationEx3 {
	public static void main(String[] args) {
		int num1 = 10;
		int i = 2;
		//논리 곱에서 앞 항의 결과 값이 거짓이므로 뒤 항의 문장은 실행되지 않음
		boolean value = ((num1 = num1+10) < 10) && ((i=i+2) <10);
		System.out.println(value);
		System.out.println(num1)
		System.out.println(i);
		//논리 합에서 앞 항의 결과 값이 참이므로 뒤 항의 문장을 실행되지 않음
		value = ((num1 = num1 +10) > 10) || ((i=i+2)<10);
		System.out.println(value);
		System.out.println(num1);
		System.out.println(i);
	}
}
```

## 17. 조건 연산자를 사용하여 부모님의 나이 비교하기

```java
public class OperationEx4 {
  public static void main(String[] args) {
    int fatherAge = 45;
    int motherAge = 47;
		// 조건식이 True 일 경우 앞에있는 'T' 문자를 변수에 저장
		// 조건식이 false 일 경우 뒤에있는 'F' 문자를 변수에 저장
    char ch;
    ch = (fatherAge > motherAge) ? 'T' : 'F';
		
    System.out.println(ch);
  }
}
```

## 18. 비트 이동 연산자를  사용하여 연산하기

```java
public class OperationEx5 {
  public static void main(String[] args) {
    int num = 0B00000101; //5를 8비트 2진수로 나타냄

    System.out.println(num << 2); // 왼쪽으로 2비트 이동 00010100(20)
    System.out.println(num >> 2); // 오른쪽으로 2비트 이동 00000001(1)
    System.out.println(num >>> 2); // 오른쪽으로 2비트 이동 00000001(1)

    System.out.println(num); //num에 값을 대입하지 않았으므로 비트 이동과 관계없이 기존값 그대로 출력

    num = num << 2; //왼쪽으로 2비트 이동한 값을 다시 num에 대입
    System.out.println(num);
  }
}
```

## 19. 나이에 따라 다른 문장 출력하기

```java
public class IfExample1 {
	public static void main(String[] args) {
		int age = 7;
		if(age >= 8) { //변수 age 데이터 값이 8이상일때
			System.out.println("학교에 다닙니다.");
		}
		else { //변수 age 데이터 값이 8이상이 아닌 나머지 일때
			System.out.println("학교에 다니지 않습니다.");
		}
	}
}
```

## 20. if-else if-else문으로 입장료 계산하기

```java
public class IfExample2 {
	public static void main(String[] args) {
		int age = 9;
		int charge;
		
		if(age < 8) { //변수 age 값이 8 미만일 경우
			charge = 1000;
			System.out.println("취학 전 아동입니다.");
		}
		else if(age < 14) { // 변수 age 값이 14 미만일 경우
			charge = 2000;
			System.out.println("초등학생입니다.");
		}
		else if(age < 20) { // 변수 age 값이 20 미만일 경우
			charge = 2500;
			System.out.println("중.고등학생입니다.");
		}
		else { // 위에 조건문에 해당하지않는 나머지
			charge = 3000;
			System.out.println("일반인입니다.");
		}
		System.out.println("입장료는" + charge + "원입니다.");//각 조건문에 해당하면 charge 값이 대입된다.
	}
}
```

## 21. switch - case문 예제

```java
public class SwitchCase {
	public static void main(String[] args) {
		int ranking = 1;
		char medalColor;
		
		switch(ranking) { //ranking 값에 따른 조건문
			case 1: medalColor = 'G'; //ranking 값이 1일때
					break;			//break; 를 쓰지않으면 밑에 default 조건일때까지 강제실행
			case 2: medalColor = 'S'; //ranking 값이 2일때
					break;
			case 3: medalColor = 'B'; //ranking 값이 3일때
					break;
			default:				  //ranking 값이 위에 해당하지 않을때
					medalColor = 'A';
		}
		System.out.println(ranking + "등 메달의 색깔은" + medalColor + "입니다");
	}
}
```

## 22. switch - case문 예제 (2)

```java
public class SwitchCase2 {
	public static void main(String[] args) {
		String medal = "Gold";
		
		switch(medal) { //medal 값에 따른 조건문
			case "Gold": //medal 값이 "Gold"일 경우
				System.out.println("금메달입니다.");
				break;			//break; 를 쓰지않으면 밑에 default 까지 강제실행
			case "Silver":
				System.out.println("은메달입니다."); //medal 값이 "Silver"일 경우
				break;
			case "Bronze":
				System.out.println("동메달입니다."); //medal 값이 "Bronze"일 경우
				break;
			default:				  //medal 값이 위에 해당하지 않을때
				System.out.println("메달이 없습니다.");
				break;
		}
	}
}
```

## 23. 1부터 10까지 더하기

```java
public class BasicLoop {
	public static void main(String[] args) {
		int num = 1;
		num += 2; //+= 는 변수에 더한값을 다시 대입한다는 뜻이다.(= num = num+2)
		num += 3;
		num += 4;
		num += 5;
		num += 6;
		num += 7;
		num += 8;
		num += 9;
		num += 10;
		
		System.out.println("1부터 10까지의 합은 " + num + "입니다.");
	}
}
```

## 24. while문 활용하여 1부터 10까지 더하기

```java
public class WhileExample1 {
	public static void main(String[] args) {
		int num = 1;
		int sum = 0;
		
		//조건식이 True인 동안 반복 수행
		while(num <= 10) { //num 값이 10보다 작거나 같을동안
			sum += num;	   //합계를 뜻하는 sum에 num을 더하고
			num++;		   //num에 1씩 더해나감
		}
		System.out.println("1부터 10까지의 합은 " + sum + "입니다.");
	}
}
```

## 25. do - while문 예제

```java
public class DoWhileExaple {
	public static void main(String[] args) {
		int num = 1;
		int sum = 0;
		
		do {
			sum += num; //do는 조건식이 참이 아니더라도 무조건 한 번은 수행함
			num++;
		} while(num <= 10);
		
		System.out.println("1부터 10까지의 합은 " + sum + "입니다.");
	}
}
```

## 26. for문 예제

```java
public class ForExample1 {
	public static void main(String[] args) {
		int i;
		int sum;
		//  i와sum 값 초기화, i는 10이하인 조건, i증가 
		for(i = 1, sum = 0; i <= 10; i++) {//for문에서 가장 자주사용하는 변수이름은 i이다.
			sum+=i;                        //주로 횟수를 표현한다.
		}
		
		System.out.println("1부터 10까지의 합은 " + sum + "입니다.");
	}
}
```

## 27. 중첩된 반목문

```java
public class NestedLoop {
	public static void main(String[] args) {
		int dan;
		int times;
		//2단 부터 9단까지 반복하는 외부 반복문
		for(dan = 2; dan <=9; dan++) {
			//각 단에서 1~9를 곱하는 내부 반복문
			for(times = 1; times <= 9; times++) {
				//내부 반복문이 다돌면 dan이 1증가 하고 다시 내부반복문을 반복한다.
				System.out.println(dan + "X" + times + "=" + dan * times);
			}
			System.out.println(); // 한 단이 끝날때마다 한줄띄워서 출력
		}
	}
}
```

## 28. continue문 예제

```java
public class ContinueExample {
	public static void main(String[] args) {
		int total = 0;
		int num;
		
		for(num = 1; num <= 100; num++) { // num값이 100까지 반복
			if(num % 2 == 0) // num값이 짝수인 경우
				continue; // 이후 수행을 생략하고 반복문 다시 시작
			total += num; // num 값이 홀수인 경우에만 수행
		}
		System.out.println("1부터 100까지의 홀수의 합은 : " + total + "입니다.");
	}
}
```

## 29. break문 예제

```java
public class BreakExample2 {
	public static void main(String[] args) {
		int sum = 0;
		int num = 0;
		//조건식을 생략하는 대신 break문을 사용
		for(num = 0; ; num++) {
			sum+= num;
			if(sum>=100) // sum이 100보다 크거나 같을 때(종료 조건)
				break;     // 반복문 중단
		}
		System.out.println("num : " + num);
		System.out.println("sum : " + sum);
	}
}
```

## 30. 학생 클래스 만들기

```java
//class : 클래스를 만드는 예약어, Student : 클래스 이름
public class Student { //클래스 안에 만든 변수는 멤버 변수라 칭함
	int studentID; // 학번
	String studentName; // 학생 이름
	int grade; // 학년
	String address; // 사는 곳
}
```

## 31. Person 클래스 만들기

```java
public class Person {
	String name; // 이름
	int height; // 키
	double weight; // 몸무게
	char gender; // 성별
	boolean married; // 결혼 여부
/*
변수의 자료형은 기본자료형, 참조자료형으로 나뉨
기본 자료형 : int, long, float, double 등
참조 자료형 : String, Date, Student 등 개발자가 직접 만든 객체(=클래스)도 사용 가능
*/
}
```

## 32. 학생 이름과 주소 출력하는 메서드 만들기

```java
public class Student { //클래스 안에 만든 변수는 멤버 변수라 칭함
	int studentID; // 학번
	String studentName; // 학생 이름
	int grade; // 학년
	String address; // 사는 곳
	
	public void showStudentInfo() { // 메서드 추가
		System.out.println(studentName + "," + address); // 이름, 주소 출력
	}// 메서드란 ? 클래스 내부에서 멤버변수를 사용하여 클래스 기능을 
   // 구현한 것을 [멤버함수] 또는 [메서드]라고 한다.
}
```

## 33. 함수 구현하고 호출하기

```java
public class BasicLoop {
	public static void main(String[] args) {
		int num1 = 10;
		int num2 = 20;
		
		int sum = add(num1, num2); // add() 함수 호출
		System.out.println(num1 + "+" + num2 + "=" + sum + "입니다");
		}
	//int :  함수 반환형, add : 함수 이름, int n1,n2 : 매개변수, return : return 예약어
	public static int add(int n1, int n2) { //add() 함수
		int result = n1 + n2;
		return result; // return 값이 없으면 함수 수행 종료로 사용하기도함
	}
}
```

## 34. 학생 이름을 반환하는 메서드

```java
public class Student{
	int studentID;
	String studentName;
	int grade;
	String address;
	
	public String getStudentName() { // 학생이름을 반환하는 메서드
		return studentName;
	}
}
```

## 35. 학생 이름을 부여하는 메서드

```java
public class Student{
	int studentID;
	String studentName;
	int grade;
	String address;
	
	public String setStudentName(String name) { // 학생 이름을 매개변수로 전달
		studentName = name;                      //전달 받은 학생이름을 멤버변수에 저장
	}
}
```

## 36. Student 클래스에 main() 함수 추가하기

```java
public class Student{
	int studentID;
	String studentName;
	int grade;
	String address;
	
	public String getStudentName() {
		return studentName;
	}
	
	public static void main(String[] args) {
		Student studentAhn = new Student(); //Student 클래스 생성
		studentAhn.studentName = "안연수"; //Student 클래스 멤버변수 studentName에 "안연수" 대입
		
		System.out.println(studentAhn.studentName); // studentName 출력
		System.out.println(studentAhn.getStudentName()); //getStudentName 메서드 호출, 반환값인 studentName 출력
	}
}
```

## 37. StudentTest 실행 클래스 만들기

```java
// 같은 패키지 안에 있으면 메인코드만 있어도 사용가능하다.
// 다른 패키지에 있으면 import문을 사용해야된다.
public class StudentTest{
	public static void main(String[] args) {
		Student studentAhn = new Student(); //Student 클래스 생성
		studentAhn.studentName = "안승연";
		
		System.out.println(studentAhn.studentName);
		System.out.println(studentAhn.getStudentName());
	}
}
```

## 38. 인스턴스 여러 개 생성하기

```java
// 인스턴스 란? 클래스가 메모리 공간에 생선된 상태를 인스턴스라고 함.
public class StudentTest1{
	public static void main(String[] args) {
		Student student1 = new Student(); //첫 번째 학생 생성
		student1.studentName = "안연수";
		
		System.out.println(student1.getStudentName());
		
		Student student2 = new Student(); //두 번째 학생 생성
		student2.studentName = "안승연";
		
		System.out.println(student2.getStudentName());
	}
}
//Student student1 = new Student(); =>
//student1 이라는 지역 변수 안에 생성된 Student1 인스턴스의 힙 메모리 주소를 대입하는것

```

## 39. 참조 값 출력하기

```java
public class StudentTest2{
	public static void main(String[] args) {
		Student student1 = new Student(); //Student 클래스 생성
		student1.studentName = "안연수";
		
		Student student2 = new Student(); //Student 클래스 생성
		student2.studentName = "안승연";
		
		System.out.println(student1); //참조 변수값 출력
		System.out.println(student2);
	}
}
// 나오는 값이 student1, student2 힙 메모리의 주소 값이다.
// 따라서 student1을 사용하여 student1 인스턴스를 참조할 수 있다.

/* 용어 설명

객체 : 객체 지향 프로그램의 대상, 생성된 인스턴스
클래스 : 객체를 프로그래밍하기 위해 코드로 만든 상태
인스턴스 : 클래스가 메모리에 생성된 상태
멤버 변수 : 클래스의 속성, 특성
메서드 : 멤버 변수를 이용하여 클래스의 기능을 구현
참조 변수 : 메모리에 생성된 인스턴스를 가리키는 변수
참조 값 : 생성된 인스턴스의 메모리 주소 갑

*/
```

## 40. 생성자 만들기

```java
public class Person {
	String name;
	float height;
	float weight;
}
```

## 41. 생성자 테스트 하기

```java
public class PersonTest{
	public static void main(String[] args) {
		Person personLee = new Person(); //Person() : 생성자
	}
}
//생성자 란? 클래스를 처음 만들 때 멤버 변수나 상수를 초기화 하는것
```

## 42. 디폴트 생성자

```java
public class Person {
	String name;
	float height;
	float weight;

	public Person() { } // 자바 컴파일러가 자동으로 제공하는 디폴트 생성자. 생략가능
}
//디폴트 생성자 란? 자바 컴파일러에서 자동으로 생성자를 만들어주는 생성자
//                 매개변수가 없고 구현 코드도 없다. 개발자가 디폴트 생성자를
//                 직접 만드는 경우에는 필요에따라 위처럼 직접 코드를 구현한다.
```

## 43. 생성자 만들기

```java
public class Person {
	String name;
	float height;
	float weight;
	
	public Person(String pname) { // 사람 이름을 매개변수로 입력받아서 Person 클래스를 생성하는 생성자
		name = pname;
	}
}
```

## 44. 생성자 테스트하기

```java
public class PersonTest{
	public static void main(String[] args) {
		Person personLee = new Person(); // Person() 부분 오류 발생
																	   // 오류를 없애려면 매개변수가 있는 생성자로 호출하거나
																	   // 개발자가 디폴트 생성자를 추가로 직접 구현하면 된다.
	}
}
```

## 45. 디폴트 생성자 직접 추가하기

```java
public class Person {
	String name;
	float height;
	float weight;

	public Person() { } //디폴트 생성자 직접 추가
                      //44.예제문에서 오류가 없어지는걸 확인가능함.
	
	public Person(String pname) {
		name = pname;
	}
}
```

## 46. 생성자 사용하기

```java
public class Person {
	String name;
	float height;
	float weight;
	
	public Person() { } // 디폴트 생성자
	
	public Person(String pname) { // 이름을 매개변수로 입력받는 생성자
		name = pname;
	}

	// 이름, 키, 몸무게를 매개변수로 입력받는 생성자
	public Person(String pname, float pheight, float pweight) {
		name = pname;
		height = pheight;
		weight = pweight;
	}
}
```

## 47. 46번 예제 테스트 클래스 구현하기

```java
public class PersonTest{
	public static void main(String[] args) {
		Person personKim = new Person(); // 디폴트 생성자로 클래스를  생성한 후
		personKim.name = "김유신";       // 인스턴스 변수 값을 따로 초기화
		personKim.weight = 85.5F;
		personKim.height = 180.0F;
		
		Person personLee = new Person("이순신", 175, 75); // 인서턴스 변수 초기화와
	}                                                   // 동시에 클래스 생성
}
```

## 48. 학생 클래스 만들기(1)

```java
public class Student1 {
	int studentID;
	String studentName;
	int koreaScore;
	int mathScore;
}
```

## 49. 학생 클래스 만들기(3)

```java
public class Student2 {
	int studentID;
	String studentName;
	int koreaScore;
	int mathScore;
	String koreaSubject; //과목 이름 변수 추가
	String mathSubjiect;
}

//위처럼 구현하면 과목에 대한 변수가 계속 늘어난다.
```

## 50. 과목 클래스 만들기

```java
public class Subject {
	String subjectName;
	int scorePoint;
}
// Subject 이라는 클래스를 새로만들어 Student 클래스에서 사용하게 만든다.
```

## 51. 학생 클래스 만들기(3)

```java
public class Student3 {
	int studentID;
	String studentName;
	Subject korean; // Subject형을 사용하여 선언
	Subject math; // Subject형을 사용하여 선언
}
// Subject 클래스를 따로 만들면 math.subjectName, korean.subjectName 이런식으로 참조하여
// 편리하게 사용할 수 있다.
```

## 52. private 사용하기

```java
public class Student {
	int studentID;
	private String studentName; //studentName 변수를 private으로 선언
	int grade;
	String address;
	
	public String getStudentName() {
		return studentName;
	}
	public void setStudentName(String studentName) {
		this.studentName = studentName;
	}
}
```

## 53. private 변수 테스트하기

```java
public class PersonTest{
	public static void main(String[] args) {
		Student studentLee = new Student();
		studentLee.studentName = "이상원"; // 오류 발생
		//private은 외부 클래스의 접근이 허용되지 않기때문에 오류 발생
		
		System.out.println(studentLee.getStudentName());
	}
}
```

## 53. get(), set() 메서드 사용하기

```java
public class Student {
	int studentID;
	private String studentName;
	int grade;
	String address;
	
	public String getStudentName() { //private 변수인 studentName에 접근해 값을 가져오는
		return studentName;            //public get() 메서드
	}
	public void setStudentName(String studentName) { //private 변수인 studentName
		this.studentName = studentName;                //에 접근해 값을 지정하는 public
	}                                                //set() 메서드
}
```

## 54. private 변수에 접근하기

```java
public class PersonTest{
	public static void main(String[] args) {
		Student studentLee = new Student();
		//studentLee.studentName = "이상원";
		studentLee.setStudentName("이상원"); //setStudnetName()메서드를 활용해 private
		                                    //변수에 접근가능
		System.out.println(studentLee.getStudentName());
	}
}
/* 접근 제어자

public : 외부 클래스 어디에서나 접근할 수 있습니다.
protected : 같은 패키지 내부와 상속 관계의 클래스에서만 접근할 수 있고
            그 외 클래스에서는 접근할 수 없습니다.
아무것도 없는 경우 : default이며 같은 패키지 내부에서만 접근할 수 있습니다.
private : 같은 클래스 내부에서만 접근할 수 있습니다.

*/
```

## 55. this 출력하기

```java
class BirthDay {
	int day;
	int month;
	int year;
	
	public void setYear(int year) { //태어난 연도를 지정하는 메서드
		this.year = year; //bDay.year = year;와 같음
	}
	
	public void printThis() { //this 출력 메서드
		System.out.println(this); //System.out.println(bDay);와 같음
	}
}

public class ThisExample{
	public static void main(String[] args) {
		BirthDay bDay = new BirthDay();
		bDay.setYear(2000); //태어난 연도를 2000으로 지정
		System.out.println(bDay); //참조 변수 출력
		bDay.printThis(); //this 출력 메서드 호출
	}
}
//클래스 코드에서 사용하는 this는 생성된 인스턴스 자신을 가리키는 역할
//this.year = year;문장으로 참조하면 동적 메모리에 생성된 인스턴스의 year 변수 위치를
//가리키고 그 위치에 매개변수 값을 넣어주는 것
```

## 56. this로 다른 생성자 호출하기

```java
class Person {
	String name;
	int age;
	
	Person(){
		this("이름 없음", 1);//this를 사용해 Person(String,int) 생성자 호출
                        //this를 사용하여 생성자를 호출하는 코드 이전에 다른코드를
                        //넣을 수 없습니다.
	}
	
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}
public class ThisExample{
	public static void main(String[] args) {
		Person noName = new Person();
		System.out.println(noName.name);
		System.out.println(noName.age);
	}
}
```

## 57. this를 사용하여 주소 값 반환하기

```java
class Person {
	String name;
	int age;
	
	Person(){
		this("이름 없음", 1);
	}
	
	Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
//반환형은 클래스형
	Person returnItSelf() {
		return this; //this 반환
	}
}
public class ThisExample{
	public static void main(String[] args) {
		Person noName = new Person();
		System.out.println(noName.name);
		System.out.println(noName.age);
		
		Person p = noName.returnItSelf(); //this 값을 클래스 변수에 대입
		System.out.println(p);            //noName.returnItSelf()의 반환 값 출력
		System.out.println(noName);       //참조 변수 출력
	}
}
//클래스 자료형과 상관없 이 클래스 내에서 this를 사용하면 
//자신의 주소값을 반환할 수 있다.
```

## 58. 학생 클래스 구현하기

```java
public class Student {
	public String studentName; //학생 이름
	public int grade; //학년
	public int money; //학생이 가지고 있는 돈
	
	public Student(String studentName, int money) {
		this.studentName = studentName; //학생 이름과 가진 돈을 매개변수로 받는 생성자
		this.money = money;
	}
	
	public void takeBus(Bus bus) {
		bus.take(1000); //학생이 버스를 타면 1000원을 지불하는 기능을 구현한 메서드
		this.money -= 1000;
	}
	
	public void takeSubway(Subway subway) {
		subway.take(1500); //학생이 지하철을 타면 1500원을 지불하는 기능을 구현한 메서드
		this.money -= 1500;
	}
	
	public void showInfo() { //학생의 현재 정보를 출력하는 메서드
		System.out.println(studentName + "님의 남은 돈은" + money + "입니다.");
	}
}
```

## 59. 버스 클래스 구현하기

```java
public class Bus {
	int busNumber; //버스 번호
	int passengerCount; //승객 수
	int money; //버스 수입
	
	public Bus(int busNumber) { //버스 번호를 매개변수로 받는 생성자
		this.busNumber = busNumber;
	}
	
	public void take(int money) { //승객이 버스에 탄 경우를 구현한 메서드
		this.money += money; //버스 수입 증가
		passengerCount++; //승객 수 증가
	}
	
	public void showInfo() { //버스 정보를 출력하는 메서드
		System.out.println("버스" + busNumber + "번의 승객은" + passengerCount + "명이고,수입은"
				+ money + "입니다.");
	}
}
```

## 60. 지하철 클래스 구현하기

```java
public class Subway {
	String lineNumber; //지하철 노선
	int passengerCount; //승객 수
	int money; //지하철 수입
	
	public Subway(String lineNumber) { //지하철 노선 번호를 매개변수로 받는 생성자
		this.lineNumber = lineNumber;
	}
	
	public void take(int money) { //승객이 지하철에 탄 경우를 구현한 메서드
		this.money += money; //수입 증가
		passengerCount++; //승객 수 증가
	}
	
	public void showInfo() { //지하철 정보 출력하는 메서드
		System.out.println(lineNumber + "의 승객은" + passengerCount + "명이고, 수입은"
				+ money + "입니다.");
	}
}
```

## 61. 버스와 지하철 타기

```java
public class TakeTrans {

	public static void main(String[] args) {
		Student studentJames = new Student("James", 5000); //학생 2명 생성
		Student studentTomas = new Student("Tomas", 10000);
		
		Bus bus100 = new Bus(100); //노선 번호가 100번인 버스 생성
		studentJames.takeBus(bus100); //james가 100번 버스를 탐
		studentJames.showInfo(); //james 정보 출력
		bus100.showInfo(); //버스 정보 출력
		
		Subway subwayGreen = new Subway("2호선"); //노선 번호가 2호선인 지하철 생성
		studentTomas.takeSubway(subwayGreen); //Tomas가 2호선을 탐
		studentTomas.showInfo(); //Tomas 정보 출력
		subwayGreen.showInfo();
	}

}
```

## 62. static 변수 사용하기

```java
public class Student {
	public static int serialNum = 1000; //static 변수는 인스턴스 생성과 상관없이 먼저 생성됨
	public int studentID;
	public String studentName;
	public int grade;
	public String address;
	
	public String getStudentName( ) {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
```

## 63. static 변수 테스트하기

```java
public class StudentTest1 {
	public static void main(String[] args) {
		Student studentLee = new Student();
		studentLee.setStudentName("이지원");
		System.out.println(studentLee.serialNum);
		studentLee.serialNum++; //static 변수 값 증가
		
		Student studentSon = new Student();
		studentSon.setStudentName("손수경");
		System.out.println(studentSon.serialNum); //증가된 값 출력
		System.out.println(studentLee.serialNum);
	}
}
//static으로 선언한 serialNum 변수는 모든 인스턴스가 공유한다.
```

## 64. 학번 자동으로 부여하기

```java
public class Student1 {
	public static int serialNum = 1000;
	public int studentID;
	public String studentName;
	public int grade;
	public String address;
	
	public Student1() { //생성자가 생성될때마다 실행
		serialNum++; //학생이 생성될 대마다 증가
		studentID = serialNum; //증가된 값을 학번 인스턴스 변수에 부여
	}
	
	public String getStudentName( ) {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
}
```

## 65. 학번 확인하기

```java
public class StudentTest1 {
	public static void main(String[] args) {
		Student1 studentLee = new Student1();
		studentLee.setStudentName("이지원");
		System.out.println(studentLee.serialNum);
		System.out.println(studentLee.studentName+"학번:"+studentLee.studentID);
		
		Student1 studentSon = new Student1();
		studentSon.setStudentName("손수경");
		System.out.println(studentSon.serialNum);
		System.out.println(studentSon.studentName+"학번:"+studentSon.studentID);
	}
}
```

## 66. 클래스 이름으로 static 변수 참조하기

```java
public class StudentTest1 {
	public static void main(String[] args) {
		Student1 studentLee = new Student1();
		studentLee.setStudentName("이지원");
		System.out.println(Student1.serialNum); //serialNum 변수를 직접 클래스 이름으로 참조
		System.out.println(studentLee.studentName+"학번:"+studentLee.studentID);
		
		Student1 studentSon = new Student1();
		studentSon.setStudentName("손수경");
		System.out.println(Student1.serialNum); //serialNum 변수를 직접 클래스 이름으로 참조
		System.out.println(studentSon.studentName+"학번:"+studentSon.studentID);
	}
}
//static 변수는 클래스 이름으로 직접 참조가 가능하다.
```

## 67. serialNum의 get(),set() 메서드 사용하기

```java
public class Student2 {
	private static int serialNum = 1000; //private 변수로 변경
	public int studentID;
	public String studentName;
	public int grade;
	public String address;
	
	public Student2() {
		serialNum++;
		studentID = serialNum;
	}
	
	public String getStudentName( ) {
		return studentName;
	}
	
	public void setStudentName(String name) {
		studentName = name;
	}
	
	public static int getSerialNum() { //serialNum의 get() 메서드
		int i =10;
		return serialNum;
	}
	
	public static void setSerialNum(int serialNum) { //serialNum의 set() 메서드
		Student2.serialNum = serialNum;
	}
}
```

## 68. 학번 출력하기

```java
public class StudentTest4 {
	public static void main(String[] args) {
		Student2 studentLee = new Student2();
		studentLee.setStudentName("이지원");
		System.out.println(Student2.getSerialNum()); //SerialNum 값을 가져오기 위해 get()
																								 //메서드를 클래스 이름으로 직접 호출
		System.out.println(studentLee.studentName+"학번:"+studentLee.studentID);
		
		Student2 studentSon = new Student2();
		studentSon.setStudentName("손수경");
		System.out.println(Student2.getSerialNum()); //SerialNum 값을 가져오기 위해 get()
																								 //메서드를 클래스 이름으로 직접 호출
		System.out.println(studentSon.studentName+"학번:"+studentSon.studentID);
	}
}
```

## 69. studentName 변수 살펴보기

```java
public class StudentTest5 {
	public static void main(String[] args) {
		System.out.println(Student2.getSerialNum()); //인스턴스 생성 없이 호출 가능
	}
}
//studentName처럼 인스턴스가 생성되어야 메모리가 할당되는
//인스턴스 변수는 클래스 메서드에서 사용할수 없다.
```

## 70. 변수 유형에 따른 용도

[제목 없음](https://www.notion.so/5760822569824c068cecc970c595b040)

## 71. private 생성자 만들기

```java
public class Company {
	private Company() {
		
	}
}
```

## 72. 인스턴스 생성하기

```java
public class Company {
	private static Company instance = new Company(); //유일하게 생성한 인스턴스
	private Company() {
		
	}
}
```

## 73. public 메서드 만들기

```java
public class Company {
	private static Company instance = new Company();
	private Company() {
		
	}
	
	public static Company getInstance() { //인스턴스를 외부에서 참조할 수 있도록
		if(instance == null) {              //public get() 메서드 구현
			instance = new Company();
			
		}
		return instance; //유일하게 생성한 인스턴스 반환
	}
}
```

## 74. 변수의 주소 값 비교하기

```java
public class CompanyTest {
	public static void main(String[] args) {
		Company myCompany1 = Company.getInstance(); //클래스 이름으로 getInsatance()
		Company myCompnay2 = Company.getInstance(); //호출하여 참조 변수에 대입
		System.out.println(myCompany1 == myCompnay2); //두 변수가 같은 주소인지 확인
	}
}
```

## 75. 배열 초기화하고 출력하기

```java
public class ArrayTest {
	public static void main(String[] args) {
		int[] num = new int[] {1,2,3,4,5,6,7,8,9,10};
		
		for(int i = 0; i<num.length; i++ ) { //배열의 첫 번째 요소(num[0])부터 열 번째
			System.out.println(num[i]);        //요소(num[9])까지 10개 요소 값 출력
		}
	}
}
```

## 76. 배열 길이만큼 출력하기

```java
public class ArrayTest2 {
	public static void main(String[] args) {
		double[ ] data = new double[5]; //double 형으로 길이 5인 배열 선언
		
		data[0] = 10.0; //첫 번째 요소에 값 10.0 대입
		data[1] = 20.0; //두 번째 요소에 값 20.0 대입
		data[2] = 30.0; //세 번째 요소에 값 30.0 대입
		
		for(int i = 0; i<data.length; i++) { //전체 배열 길이만큼 반복
			System.out.println(data[i]);
		}
	}
}
```

## 77. 배열의 유효한 요소 값 출력하기

```java
public class ArrayTest3 {
	public static void main(String[] args) {
		double[ ] data = new double[5];
		int size =0; //유효한 값이 저장된 배열 요소 개수를 저장할 변수 선언
		
		data[0] = 10.0; size++; //값을 저장한 후 size 변수 값 증가
		data[1] = 20.0; size++;
		data[2] = 30.0; size++;
		
		for(int i = 0; i<size; i++) { //유효한 값이 저장된 배열 요소 개수만큼 반복문 실행
			System.out.println(data[i]);
		}
	}
}
```

## 78. 알파벳 문자와 아스키 코드 값 출력하기

```java
public class ArrayTest3 {
	public static void main(String[] args) {
		char[] alphabets = new char[26];
		char ch = 'A';
		
		for(int i=0; i<alphabets.length; i++, ch++) {
			alphabets[i] = ch; //아스키 값으로 각 요소에 저장
		}
		
		for(int i=0; i<alphabets.length; i++) {
			System.out.println(alphabets[i] + "," + (int)alphabets[i]);
			
		}
	}
}
```

## 79. 객체 배열 만들기 (1)

```java
public class Book {
	private String bookName;
	private String author;
	
	public Book() {} //디폴트 생성자
	
	public Book(String bookName, String author) { //책 이름과 저자 이름을 매개변수로
		this.bookName = bookName;                 //받는 생성자
		this.author = author;
	}
	
	public String getBookName() {
		return bookName;
	}
	
	public void setBookName(String bookName) {
		this.bookName = bookName;
	}
	
	public String getAuthor() {
		return author;
	}
	
	public void setAuthor(String author) {
		this.author = author;
	}
	
	public void showBookInfo( ) { //책 정보를 출력해 주는 메서드
		System.out.println(bookName + ","+ author);
	}
}
```

## 80. 객체 배열 만들기 (2)

```java
public class BookArray {
	public static void main(String[] args) {
		Book[] library = new Book[5]; //Book 클래스형으로 객체 배열 생성
		
		for(int i = 0; i<library.length; i++) {
			System.out.println(library[i]);
		}
	}
}
```

## 81. 객체 배열 만들기 (3)

```java
public class BookArray2 {
	public static void main(String[] args) {
		Book[] library = new Book[5];
		
		library[0] = new Book("태백산맥","조정래"); //인스턴스 생성후 배열에 저장
		library[1] = new Book("데미안","헤르만 헤세");
		library[2] = new Book("어떻게 살 것인가","유시민");
		library[3] = new Book("토지","박경리");
		library[4] = new Book("어린왕자","생텍쥐페리");
		
		for(int i = 0; i<library.length; i++) { //인스턴스 멤버들
			library[i].showBookInfo();
		}
		
		for(int i = 0; i<library.length; i++) { //Book 인스턴스를 저장한 메모리 공간 주소
			System.out.println(library[i]);
		}
	}
}
```

## 82. System.arraycopy()로 배열 복사하기

```java
public class ArrayCopy {
	public static void main(String[] args) {
		int[] array1 = {10,20,30,40,50};
		int[] array2 = {1,2,3,4,5};
		
		//arraycopy(복사할 배열, 복사할 첫 위치, 대상 배열, 붙여넣을 첫 위치, 복사할 요소 개수)
		System.arraycopy(array1,0,array2,1,4);
		for(int i = 0; i < array2.length; i++) {
			System.out.println(array2[i]);
		}
	}
}
```

## 83. 객체 배열 복사하기

```java
public class ObjectCopy1 {
	public static void main(String[] args) {
		Book[] bookArray1 = new Book[3];
		Book[] bookArray2 = new Book[3];
		
		bookArray1[0] = new Book("태백산맥","조정래"); 
		bookArray1[1] = new Book("데미안","헤르만 헤세");
		bookArray1[2] = new Book("어떻게 살 것인가","유시민");
		System.arraycopy(bookArray1, 0, bookArray2, 0, 3);
	
		for(int i = 0; i<bookArray2.length; i++) { 
			bookArray2[i].showBookInfo();
		}
	}
}
```

## 84. 객체 배열의 얕은 복사

```java
public class ObjectCopy2 {
	public static void main(String[] args) {
		Book[] bookArray1 = new Book[3];
		Book[] bookArray2 = new Book[3];
		
		bookArray1[0] = new Book("태백산맥","조정래"); 
		bookArray1[1] = new Book("데미안","헤르만 헤세");
		bookArray1[2] = new Book("어떻게 살 것인가","유시민");
		System.arraycopy(bookArray1, 0, bookArray2, 0, 3);
	
		for(int i = 0; i<bookArray2.length; i++) { 
			bookArray2[i].showBookInfo();
		}
		
		System.out.println("=== bookArray1 ===");
		bookArray1[0].setBookName("나목"); //bookArray1 배열의 첫 번째 요소 값 변경
		bookArray1[0].setAuthor("박완서");
		for(int i = 0; i<bookArray1.length; i++) { 
			bookArray1[i].showBookInfo();
		}
		
		System.out.println("=== bookArray2 ===");
		for(int i = 0; i<bookArray2.length; i++) { 
			bookArray2[i].showBookInfo(); //booArray2 배열 요소 값도 변경되어 출력
		}
	}
}
//arraycopy를 이용하면 인스턴스 주소값이 복사가 된다.
```

## 85. 객체 배열의 깊은 복사

```java
public class ObjectCopy2 {
	public static void main(String[] args) {
		Book[] bookArray1 = new Book[3];
		Book[] bookArray2 = new Book[3];
		
		bookArray1[0] = new Book("태백산맥","조정래"); 
		bookArray1[1] = new Book("데미안","헤르만 헤세");
		bookArray1[2] = new Book("어떻게 살 것인가","유시민");
		
		bookArray2[0] = new Book();
		bookArray2[1] = new Book(); //디폴트 생성자로 bookArray2
		bookArray2[2] = new Book(); //배열 인스턴스 생성
	
		for(int i = 0; i<bookArray1.length; i++) { //bookArray1 배열 요소를 새로 생성한 
			bookArray2[i].setBookName(bookArray1[i].getBookName()); //bookArray2 배열
			bookArray2[i].setAuthor(bookArray1[i].getAuthor()); //인스턴스에 복사
		}
		
		for(int i = 0; i<bookArray2.length; i++) { 
			bookArray2[i].showBookInfo(); //bookArray2 배열 요소 값 출력
		}
		
		bookArray1[0].setBookName("나목"); //bookArray1 첫 번째 배열 요소 값 수정
		bookArray1[0].setAuthor("박완서");
		
		System.out.println("=== bookArray1 ===");
		for(int i = 0; i<bookArray1.length; i++) { 
			bookArray1[i].showBookInfo(); //bookArray1 배열 요소 값 출력
		}
		
		System.out.println("=== bookArray2 ===");
		for(int i = 0; i<bookArray2.length; i++) { //bookArray1 배열 요소 값과 
                                               //다른 내용이 출력됨
			bookArray2[i].showBookInfo(); //bookArray2 배열 요소 값 출력
		}
	}
}
```

## 86. 향상된 for문 사용하기

```java
public class EnhancedForLoop {
	public static void main(String[] args) {
		String[] strArray = {"Java", "Android", "C", "JavaScript", "Python"};
		
		//lang 변수에는 배열의 각 요소가 대입
		for(String lang : strArray) {
			System.out.println(lang);
		}
	}
}
```

## 87. 이차원 배열 초기화하기

```java
public class TwoDimension {
	public static void main(String[] args) {
		int[][] arr = {{1,2,3,},{4,5,6}}; //2차원 배열 선언과 동시에 초기화
		
		for(int i = 0; i < arr.length; i++) {
			for(int j = 0; j < arr[i].length; j++) {
				System.out.println(arr[i][j]);
			}
			System.out.println(); //행 출력 끝난 후 한 줄 띄움
		}
	}
}
```

## 88. 이차원 배열의 길이 출력하기

```java
public class TwoDimension2 {
	public static void main(String[] args) {
		int[][] arr = new int[2][3];
		                 //행 길이
		for(int i = 0; i < arr.length; i++) {
                         //열 길이
			for(int j = 0; j < arr[i].length; j++) {
				System.out.println(arr[i][j]);
			}
			System.out.println();
		}
		System.out.println(arr.length); //행 길이 출력
		System.out.println(arr[0].length); //열 길이 출력
	}
}
```

## 89. ArrayList 클래스 사용하기

```java
import java.util.ArrayList; //ArrayList 클래스 import 

public class TwoDimension2 {
	public static void main(String[] args) {
		ArrayList<Book> library = new ArrayList<Book>(); //ArrayList 선언
		
		library.add(new Book("태백산맹","조정래")); //add() 메서드로 요소 값 추가
		library.add(new Book("데미안","헤르만 헤세"));
		library.add(new Book("어떻게 살 것인가","유시민"));
		library.add(new Book("토지","박경리"));
		library.add(new Book("어린왕자","생텍쥐페리"));
		
		for(int i = 0; i < library.size(); i++) {
			Book book = library.get(i); //배열에 추가된 요소 개수만큼 출력
			book.showBookInfo();
		}
		
		System.out.println();
		
		System.out.println("=== 향상된 for문 사용 ===");
		for(Book book : library) {
			book.showBookInfo();
		}
	}
}
```

## 90. Student 클래스 구현하기

```java
import java.util.ArrayList;

public class Student { 
	//Student 클래스의 멤버 변수
	int studentID; 
	private String studentName;
	ArrayList<Subject> subjectList; //ArrayList 선언하기
	
	//생성자
	public Student (int studentID, String studentName) {
		this.studentID = studentID;
		this.studentName = studentName;
		subjectList = new ArrayList<Subject>(); //ArrayList 생성하기
	}
	
	//학생이 수강하는 과목을 subjectList 배열에 하나씩 추가하는 메서드
	public void addSubject(String name, int score) {
		Subject subject = new Subject(); //Subject 생성하기
		subject.setName(name); //과목 이름 추가하기
		subject.setScorePoint(score); //점수 추가하기
		subjectList.add(subject); //배열에 저장하기
	}
	
	public void showStudentInfo() {
		int total = 0;
		//배열 요소 값 출력
		for(Subject s : subjectList) {
			total += s.getScorePoint(); // 총점 더하기
			System.out.println("학생 " + studentName+ "의"+ s.getName()+" 과목 성적은 "
			+ s.getScorePoint() + "입니다.");
		}
		System.out.println("학생 " + studentName + "의 총점은 " + total + " 입니다.");
	}
	
	public String getStudentName() {
		return studentName;          
	}
	public void setStudentName(String studentName) {
		this.studentName = studentName;               
	}                                               
}
```

## 91. Subject 클래스 구현하기

```java
public class Subject {
	//Subject 클래스의 멤버 변수
	private String name; //과목 이름
	private int scorePoint; //과목 점수
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getScorePoint() {
		return scorePoint;
	}
	public void setScorePoint(int scorePoint) {
		this.scorePoint = scorePoint;
	}
}
```

## 92. 학생 성적 출력하기

```java
public class StudentTest {
	public static void main(String[] args) {
		Student studentLee = new Student(1001,"Lee");
		studentLee.addSubject("국어", 100);
		studentLee.addSubject("수학", 50);
		
		Student studentKim = new Student(1002, "Kim");
		studentKim.addSubject("국어", 70);
		studentKim.addSubject("수학", 85);
		studentKim.addSubject("영어", 100);
		
		studentLee.showStudentInfo();
		System.out.println("==========================");
		studentKim.showStudentInfo();

	}
}
```

## 93. Customer 클래스 구현하기

```java
public class Customer {
	private int customerID; //고객 아이디
	private String customerName; //고객 이름
	private String customerGrade; //고객 등급
	int bonusPoint; //보너스 포인트
	double bonusRatio; //적립 비율
	
	//디폴트 생성자
	public Customer() {
		customerGrade = "SILVER"; //기본 등급
		bonusRatio = 0.01; //보너스 포인트 기본 적립 비율
	}
	
	//보너스 포인트 적립, 지불 가격 계산 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 게산
		return price;
	}
	
	//고객 정보를 반환하는 메서드
	public String showCustomerInfo() {
		return customerName + " 님의 등급은 " 
				+ customerGrade +"이며, 보너스 포인트는"
				+ bonusPoint + "입니다.";
	}
}
```

## 94. VIPCustomer 클래스 구현하기

```java
//VIPCustomer 클래스는 Customer 클래스를 상속받음
public class VIPCustomer extends Customer {
	private int agentID; //VIP 고객 상담원 아이디
	double saleRatio; //할인율
	
	public VIPCustomer() {
		customerGrade = "VIP"; //상위 클래스에서 
													 //private 변수이므로 오류 발생
		bonusRatio = 0.05;
		saleRatio = 0.1;
	}
	
	public int getAgentID() {
		return agentID;
	}
}
```

## 95. protected 변수 선언

```java
public class Customer {
	protected int customerID; //고객 아이디
	protected String customerName; //고객 이름
	protected String customerGrade; //고객 등급
	int bonusPoint; //보너스 포인트
	double bonusRatio; //적립 비율
	
	//디폴트 생성자
	public Customer() {
		customerGrade = "SILVER"; //기본 등급
		bonusRatio = 0.01; //보너스 포인트 기본 적립 비율
	}
	
	//보너스 포인트 적립, 지불 가격 계산 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 게산
		return price;
	}
	
	//고객 정보를 반환하는 메서드
	public String showCustomerInfo() {
		return customerName + " 님의 등급은 " 
				+ customerGrade +"이며, 보너스 포인트는"
				+ bonusPoint + "입니다.";
	}
	
	//protected 예약어로 선언한 변수를 외부에서 사용할 수 있도록
	//get(), set() 메서드 추가
	public int getCustomerID() {
		return customerID;
	}
	
	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}
	
	public String getCustomerName() {
		return customerName;
	}
	
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	
	public String getCustomerGrade() {
		return customerName;
	}
	
	public void getCustomerGrade(String CustomerGrade) {
		this.customerGrade = customerGrade;
	}
}
```

## 96. 상속 클래스 테스트하기

```java
public class CustomerTest {

	public static void main(String[] args) {
		Customer customerLee = new Customer();
		customerLee.setCustomerID(10010);      //customerID와 customerName은
		customerLee.setCustomerName("이순신"); //protected 변수이므로
		customerLee.bonusPoint = 1000;         //set() 메서드 호출
		System.out.println(customerLee.showCustomerInfo());
		
		VIPCustomer customerKim = new VIPCustomer();
		customerKim.setCustomerID(10020);      //customerID와 customerName은
		customerKim.setCustomerName("김유신"); //protected 변수이므로 set() 
		customerKim.bonusPoint = 10000;        //set() 메서드 호출
		System.out.println(customerKim.showCustomerInfo());
	}

}
```

## 97. 상속에서 클래스 생성과정 (1)

```jsx
public class Customer {
	protected int customerID; //고객 아이디
	protected String customerName; //고객 이름
	protected String customerGrade; //고객 등급
	int bonusPoint; //보너스 포인트
	double bonusRatio; //적립 비율
	
	//디폴트 생성자
	public Customer() {
		customerGrade = "SILVER"; //기본 등급
		bonusRatio = 0.01; //보너스 포인트 기본 적립 비율
		//상위 클래스 생성할 때 콘솔 출력문
		System.out.println("Customer() 생성자 호출");
	}
	
	//보너스 포인트 적립, 지불 가격 계산 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 게산
		return price;
	}
	
	//고객 정보를 반환하는 메서드
	public String showCustomerInfo() {
		return customerName + " 님의 등급은 " 
				+ customerGrade +"이며, 보너스 포인트는"
				+ bonusPoint + "입니다.";
	}
	
	//protected 예약어로 선언한 변수를 외부에서 사용할 수 있도록
	//get(), set() 메서드 추가
	public int getCustomerID() {
		return customerID;
	}
	
	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}
	
	public String getCustomerName() {
		return customerName;
	}
	
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	
	public String getCustomerGrade() {
		return customerName;
	}
	
	public void getCustomerGrade(String CustomerGrade) {
		this.customerGrade = customerGrade;
	}
}
```

## 98. 상속에서 클래스 생성 과정 (2)

```jsx
public class VIPCustomer extends Customer {
	private int agentID; //VIP 고객 상담원 아이디
	double saleRatio; //할인율
	
	public VIPCustomer() {
		customerGrade = "VIP"; //사위 클래스에서 private 변수이므로 오류 발생
		bonusRatio = 0.05;
		saleRatio = 0.1;
		//하위 클래스 생성할 때 콘솔 출력문
		System.out.println("VIPCustomer() 생성자 호출");
	}
	
	public int getAgentID() {
		return agentID;
	}
}
```

## 99. 하위 클래스 생성하기

```jsx
public class CustomerTest {
	public static void main(String[] args) {
		VIPCustomer customerKim = new VIPCustomer();
		customerKim.setCustomerID(10020);
		customerKim.setCustomerName("김유신");
		customerKim.bonusPoint = 10000;
		System.out.println(customerKim.showCustomerInfo());
	}
}
//하위 클래스를 호출하면 상위클래스가 먼저 만들어지고, 그후에
//하위 클래스가 만들어지므로 상위클래스에 있는 호출문도 같이 입력됨.
```

## 100. Customer 클래스에 새로운 생성자 추가하기

```jsx
public class Customer {
	protected int customerID; //고객 아이디
	protected String customerName; //고객 이름
	protected String customerGrade; //고객 등급
	int bonusPoint; //보너스 포인트
	double bonusRatio; //적립 비율
	
	//디폴트 생성자
	public Customer() {
		customerGrade = "SILVER"; //기본 등급
		bonusRatio = 0.01; //보너스 포인트 기본 적립 비율
		System.out.println("Customer() 생성자 호출");
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		System.out.println("Customer(int,String) 생성자 호출");
	}
	
	//보너스 포인트 적립, 지불 가격 계산 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 게산
		return price;
	}
	
	//고객 정보를 반환하는 메서드
	public String showCustomerInfo() {
		return customerName + " 님의 등급은 " 
				+ customerGrade +"이며, 보너스 포인트는"
				+ bonusPoint + "입니다.";
	}
	
	//protected 예약어로 선언한 변수를 외부에서 사용할 수 있도록
	//get(), set() 메서드 추가
	public int getCustomerID() {
		return customerID;
	}
	
	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}
	
	public String getCustomerName() {
		return customerName;
	}
	
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	
	public String getCustomerGrade() {
		return customerName;
	}
	
	public void getCustomerGrade(String CustomerGrade) {
		this.customerGrade = customerGrade;
	}
}
//디폴트 생성자가 없으면 VIPCustomer 클래스에서 오류가 발생
//묵시적으로(=자동) 호출될 Customer()가 정의되지 않았기 때문이다.
```

## 101. 명시적으로 상위 클래스 생성자 호출하기

```jsx
//VIPCustomer 클래스는 Customer 클래스를 상속받음
public class VIPCustomer extends Customer {
	private int agentID; //VIP 고객 상담원 아이디
	double saleRatio; //할인율
	
	public VIPCustomer() {
		customerGrade = "VIP"; //사위 클래스에서 private 변수이므로 오류 발생
		bonusRatio = 0.05;
		saleRatio = 0.1;
		//하위 클래스 생성할 때 콘솔 출력문
		System.out.println("VIPCustomer() 생성자 호출");
	}
	
	public VIPCustomer(int customerID, String customerName, int agentID) {
		//상위 클래스 생성자 호출
		//public Customer(int customerID, String customerName) {
		//	this.customerID = customerID;
		//	this.customerName = customerName;
		//	customerGrade = "SILVER";
		//	bonusRatio = 0.01;
		//	System.out.println("Customer(int,String) 생성자 호출");
		//} 와 같다
		super(customerID, customerName);
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
	}
	
	public int getAgentID() {
		return agentID;
	}
}
```

## 102. calcPrice() 메서드 재정의하기

```jsx
//VIPCustomer 클래스는 Customer 클래스를 상속받음
public class VIPCustomer extends Customer {
	private int agentID; //VIP 고객 상담원 아이디
	double saleRatio; //할인율
	
	public VIPCustomer() {
		customerGrade = "VIP"; //사위 클래스에서 private 변수이므로 오류 발생
		bonusRatio = 0.05;
		saleRatio = 0.1;
		//하위 클래스 생성할 때 콘솔 출력문
		System.out.println("VIPCustomer() 생성자 호출");
	}
	
	public VIPCustomer(int customerID, String customerName, int agentID) {
		//상위 클래스 생성자 호출
		super(customerID, customerName);
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
		System.out.println("VIPCustomer(int, String) 생성자 호출");
	}
	
	//재정의한 메서드
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 적립
		return price = (int)(price * saleRatio); //할인된 가격을 계산하여 반환
	}
	
	public int getAgentID() {
		return agentID;
	}
}
//애노테이션(Annotation)이란?
//@Override => 재정의된 메서드라는 정보 제공
//@FuctionalInterface => 함수형 인터페이스라는 정보 제공
//@Deprecated => 이후 버전에서 사용되지 않을 수 있는 변수, 메서드에 사용됨
//@SuppressWarnings => 특정 경고가 나타나지 않도록 함
```

## 103. calcPrice() 테스트하기

```jsx
public class CustomerTest {
	public static void main(String[] args) {
		Customer customerLee = new Customer(10010, "이순신");
		customerLee.bonusPoint = 1000;
		
		VIPCustomer customerKim = new VIPCustomer(10020, "김유신", 12345);
		customerKim.bonusPoint = 10000;
		
		int price = 10000;
		System.out.println(customerLee.getCustomerName()
				+ " 님이 지불해야 하는 금액은 "
				+ customerLee.calcPrice(price)
				+ "원입니다.");
		System.out.println(customerKim.getCustomerName()
				+ " 님이 지불해야 하는 금액은 "
				+ customerKim.calcPrice(price)
				+ "원입니다.");
	}
}
//VIP 등급은 10%할인을 받아 9000원을 지불한다.
```

## 104. 클래스 형 변환과 재정의 메서드 호출하기

```jsx
public class CustomerTest {
	public static void main(String[] args) {
		Customer vc = new VIPCustomer(10030, "나몰라", 2000); //VIP 고객 생성
		vc.bonusPoint = 1000;
		
		System.out.println(vc.getCustomerName()
				+ " 님이 지불해야 하는 금액은 "
				+ vc.calcPrice(10000)
				+ "원입니다.");
	}
}
//상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할때
//호출되는 메서드는 인스턴스에 따라 결정된다.
//즉, 선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출한다.
```

## 105. 메서드 호출하기

```jsx
import java.util.*;

public class Main {
	int num;
	
	void aaa() {
		System.out.println("aaa() 출력");
	}
	public static void main(String[] args) {
		Main a1 = new Main();
		a1.aaa();
		Main a2 = new Main();
		a2.aaa();
	}
}
```

## 106. 클래스형에 기반하여 지불 금액 계산하기

```jsx
public class CustomerTest {
	public static void main(String[] args) {
		int price = 10000;
		
		//Customer 인스턴스 생성
		Customer customerLee = new Customer(10010, "이순신");
		System.out.println(customerLee.getCustomerName()
				+ " 님이 지불해야하는 금액은"
				+ customerLee.calcPrice(price)
				+ "원입니다.");
		
		//VIPCustomer 인스턴스 생성
		VIPCustomer customerKim = new VIPCustomer(10020, "김유신", 12345);
		System.out.println(customerKim.getCustomerName()
				+ " 님이 지불해야하는 금액은"
				+ customerKim.calcPrice(price)
				+ "원입니다.");
		
		//VIPCustomer 인스턴스를 Customer형으로 변환
		Customer vc = new VIPCustomer(10030, "나몰라",2000);
		System.out.println(vc.getCustomerName()
				+ " 님이 지불해야하는 금액은"
				+ vc.calcPrice(price)
				+ "원입니다.");
	}
}
```

## 106. 다형성 테스트하기

```jsx
class Animal{
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
}

class Human extends Animal{
	public void move() {
		System.out.println("사람이 두 발로 걷습니다.");
	}
}

class Tiger extends Animal{
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
}

class Eagle extends Animal{
	public void move() {
		System.out.println("독수리가 하늘을 납니다.");
	}
}

public class Main {
	public static void main(String[] args) {
		Main aTest = new Main();
		aTest.moveAnimal(new Human());
		aTest.moveAnimal(new Tiger());
		aTest.moveAnimal(new Eagle());
	}
											//매개변수의 자료형이 상위 클래스
	public void moveAnimal(Animal animal) {//(= Animal animal = new Humal())
		animal.move(); //재정의된 메서드가 호출됨.
	}
}
//다형성의 장점
//상위 클래스를 상속받아 구현하면 모든 클래스를 상위 클래스 자료형 하나로
//쉽게 관리할 수 있다.
//다형성을 화용한 프로그램의 확장성이다.
```

## 107. 고객 관리 프로그램 완성하기 (1)

```jsx
public class Customer {
	protected int customerID; //고객 아이디
	protected String customerName; //고객 이름
	protected String customerGrade; //고객 등급
	int bonusPoint; //보너스 포인트
	double bonusRatio; //적립 비율
	
	//디폴트 생성자
	public Customer() {
		//고객 등급과 보너스 포인트 적립률 지정 함수 호출
		initCustoemr();
	}
	
	public Customer(int customerID, String customerName) {
		this.customerID = customerID;
		this.customerName = customerName;
		customerGrade = "SILVER";
		bonusRatio = 0.01;
		//고객 등급과 보너스 포인트 적립률 지정 함수 호출
		initCustoemr();
	}
	
	//생성자에서만 호출하는 메서드이므로 private으로 선언
	private void initCustoemr() {//멤버 변수의 초기화 부분
		customerGrade = "SILVER";
		bonusRatio = 0.01;
	}
	
	//보너스 포인트 적립, 지불 가격 계산 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio; //보너스 포인트 게산
		return price;
	}
	
	//고객 정보를 반환하는 메서드
	public String showCustomerInfo() {
		return customerName + " 님의 등급은 " 
				+ customerGrade +"이며, 보너스 포인트는"
				+ bonusPoint + "입니다.";
	}
	
	//protected 예약어로 선언한 변수를 외부에서 사용할 수 있도록
	//get(), set() 메서드 추가
	public int getCustomerID() {
		return customerID;
	}
	
	public void setCustomerID(int customerID) {
		this.customerID = customerID;
	}
	
	public String getCustomerName() {
		return customerName;
	}
	
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	
	public String getCustomerGrade() {
		return customerName;
	}
	
	public void getCustomerGrade(String CustomerGrade) {
		this.customerGrade = customerGrade;
	}
}
```

## 108. 고객 관리 프로그램 완성하기 (2)

```jsx
//VIPCustomer 클래스는 Customer 클래스를 상속받음
public class VIPCustomer extends Customer {
	private int agentID; //VIP 고객 상담원 아이디
	double saleRatio; //할인율
	
	public VIPCustomer() {
		customerGrade = "VIP"; //사위 클래스에서 private 변수이므로 오류 발생
		bonusRatio = 0.05;
		saleRatio = 0.1;
		//하위 클래스 생성할 때 콘솔 출력문
	}
	
	public VIPCustomer(int customerID, String customerName, int agentID) {
		//상위 클래스 생성자 호출
		super(customerID, customerName);
		customerGrade = "VIP";
		bonusRatio = 0.05;
		saleRatio = 0.1;
	}
	
	//지불 가격 메서드 재정의
	@Override
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price * saleRatio);
	}
	
	//고객 정보 출력 메서드 재정의
	public String showCustomerInfo() {
		return super.showCustomerInfo() + "담당 상담원 번호는 "
				+ agentID + "입니다.";
	}
	
	public int getAgentID() {
		return agentID;
	}
}
```

## 109. 고객 관리 프로그램 완성하기 (3)

```jsx
public class CustomerTest {
	public static void main(String[] args) {
		int price = 10000;
		
		Customer customerLee = new Customer();
		customerLee.setCustomerID(10010);
		customerLee.setCustomerName("이순신");
		customerLee.bonusPoint = 1000;
		
		System.out.println(customerLee.showCustomerInfo());
		
		//VIPCustomer를 Customer형으로 선언
		Customer customerKim = new VIPCustomer(10020, "김유신", 12345);
		customerKim.bonusPoint = 1000;
		
		System.out.println(customerKim.showCustomerInfo());
		System.out.println("====== 할인율과 보너스 포인트 계산 ======");
		
		System.out.println(customerLee.getCustomerName()
				+ " 님이 지불해야하는 금액은"
				+ customerLee.calcPrice(price)
				+ "원입니다.");
		System.out.println(customerLee.showCustomerInfo());
		System.out.println(customerKim.getCustomerName()
				+ " 님이 지불해야하는 금액은"
				+ customerKim.calcPrice(price)
				+ "원입니다.");
		System.out.println(customerKim.showCustomerInfo());

	}
}
```

## 110. 새로운 고객 등급 추가하기

```jsx
public class GoldCustomer extends Customer {
	double saleRatio;
	
	public GoldCustomer (int customerID, String customerName) {
		super(customerID, customerName);
		customerGrade = "GOLD";
		bonusRatio = 0.02;
		saleRatio = 0.1;
	}
	
	//재정의한 메서드
	public int calcPrice(int price) {
		bonusPoint += price * bonusRatio;
		return price - (int)(price *  saleRatio);
	}
	
}
```

## 111. 배열을 활용한 고객 관리 프로그램 구현하기

```jsx
import java.util.ArrayList;

public class CustomerTest {
	public static void main(String[] args) {
		ArrayList<Customer> customerList = new ArrayList<Customer>();
		
		Customer customerLee = new Customer(10010, "이순신");
		Customer customerShin = new Customer(10010, "신사임당");
		Customer customerHong = new GoldCustomer(10010, "홍길동");
		Customer customerYoul = new GoldCustomer(10010, "이율곡");
		Customer customerKim = new VIPCustomer(10010, "김유신", 12345);
		
		//ArrayList의 add 속성을 사용해 객체 배열에 고객 추가
		customerList.add(customerLee);
		customerList.add(customerShin);
		customerList.add(customerHong);
		customerList.add(customerYoul);
		customerList.add(customerKim);
		
		System.out.println("====== 고객 정보 출력 ======");
		for(Customer customer : customerList) {
			System.out.println(customer.showCustomerInfo());
		}
		
		System.out.println("====== 할인율과 보너스 포인트 계산 ======");
		int price = 10000;
		//다형성 구현
		for(Customer customer : customerList) {
			int cost = customer.calcPrice(price);
			System.out.println(customer.getCustomerName()
					+ " 님이 " + cost +"원 지불하셨습니다.");
			System.out.println(customer.getCustomerName()
					+ " 님의 현재 보너스 포인트는 " 
					+ customer.bonusPoint +"점입니다.");
		}
	}
}
//자바에서는 다중상속을 지원하지않음
//상속을 받을때 어느것을 상속받아야 하는지 모호하기 때문이다.
//따라서 extends 예약어 뒤에 오는 클래스는 반드시 한 개여야 한다.
```

## 112. instanceof로 원래 인스턴스형 확인 후 다운 캐스팅하기

```jsx
import java.util.*;

//상위 클래스 Animal
class Animal{
	public void move() {
		System.out.println("동물이 움직입니다.");
	}
}

//Animal을 상속받은 Human 클래스
class Human extends Animal{
	public void move() {
		System.out.println("사람이 두 발로 걷습니다.");
	}
	public void readBook() {
		System.out.println("사람이 책을 읽습니다.");
	}
}

////Animal을 상속받은 Tiger 클래스
class Tiger extends Animal{
	public void move() {
		System.out.println("호랑이가 네 발로 뜁니다.");
	}
	public void hunting() {
		System.out.println("호랑이가 사냥을 합니다.");
	}
}

//Animal을 상속받은 Eagle 클래스
class Eagle extends Animal{
	public void move() {
		System.out.println("독수리가 하늘을 납니다.");
	}
	public void flying() {
		System.out.println("독수리가 날개를 쭉 펴고 멀리 날아갑니다.");
	}
}

public class Main {
	//배열의 자료형은 Animal로 지정
	ArrayList<Animal> aniList = new ArrayList<Animal>();

	public static void main(String[] args) {
		Main aTest = new Main();
		aTest.addAnimal();
		System.out.println("원래 형으로 다운 캐스팅");
		aTest.testCasting();
	}
	
	public void addAnimal() {//ArrayList에 추가되면서 Animal형으로 형 변환
		aniList.add(new Human());
		aniList.add(new Tiger());
		aniList.add(new Eagle());
		
		//배열 요소를 Anumal형으로 꺼내서 move()를 호출하면 재정의된 함수가 호출됨.
		for(Animal ani : aniList) {
			ani.move();
		}
	}
	
	public void testCasting() {
		for(int i = 0; i < aniList.size(); i++) {//모든 배열 요소를 하나씩 돌면서
			Animal ani = aniList.get(i);           //Anumal형으로 가져옴
			if(ani instanceof Human) {             //Human이면
				Human h = (Human)ani;                //Human형으로 다운캐스팅
				h.readBook();
			}
			else if(ani instanceof Tiger) {
				Tiger t = (Tiger)ani;
				t.hunting();
			}
			else if(ani instanceof Eagle) {
				Eagle e = (Eagle)ani;
				e.flying();
			}
			else {
				System.out.println("지원되지 않는 형입니다.");
			}
		}
	}
}
//상위클래스인 Animal형으로 호출한후
//instanceof를 사용하여  하위클래스형으로 바꿈
//예) Animal형이고 인스턴스는 하위클래스인 Human으로 호출하였을때
//Animal과 같은 메서드인 move()는 사용할 수 있지만
//Human에서만 정의된 readbook()은 사용할 수 없다.
```
