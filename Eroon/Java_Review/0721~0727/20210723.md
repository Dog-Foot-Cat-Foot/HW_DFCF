## 자바 JDK로 프로그래밍 날개 달기

### 12. 컬렉션 프레임워크

1. 제네릭
    - 제네릭이란?

         - 제네릭(Generic) 프로그래밍

        : 어떤 값이 하나의 참조 자료형이 아닌 여러 참조 자료형을 사용할 수 있도록 프로그래밍 하는 것

        → 참조 자료형이 변환될 때 이에 대한 검증을 컴파일러가 하므로 안정적임

         - 컬렉션 프레임워크도 많은 부분이 제네릭으로 구현되어 있음

    - 제네릭의 필요성

         > 3D 프린터를 예로 들어 제네릭에 대해 이해하기

        ```java
        public class ThreeDPringer{
        	//멤버변수
        	//private 접근 지정자로 설정
        	private Powder material; // 재료가 파우더인 경우

        	//생성자
        	public void setMaterial(Powder material){
        		this.material = material;
        	}
        	//메소드
        	// material이 private이므로 get 메소드 생성
        	public Powder getMaterial(){
        		return material;
        	}
        }

        public class ThreeDPringer{
        	//멤버변수
        	//private 접근 지정자로 설정
        	private Plastic material; // 재료가 플라스틱인 경우

        	//생성자
        	public void setMaterial(Plastic material){
        		this.material = material;
        	}
        	//메소드
        	// material이 private이므로 get 메소드 생성
        	public Plastic getMaterial(){
        		return material;
        	}
        }
        ```

        → 재료만 바뀌고 프린터 기능이 동일하다면 프린터 클래스를 두개 만드는 것은 비효율적

        어떤 재료든 쓸 수 있도록 material 변수의 자료형을 Object로 사용할 수 있음

         Object는 모든 클래스의 최상위 클래스이므로 모든 클래스는 Object로 변환할 수 있음

        ```java
        public class ThreeDPringer{
        	//멤버변수
        	//private 접근 지정자로 설정
        	private Object material; // 재료가 플라스틱인 경우

        	//생성자
        	public void setMaterial(Object material){
        		this.material = material;
        	}
        	//메소드
        	// material이 private이므로 get 메소드 생성
        	public Object getMaterial(){
        		return material;
        	}
        }
        ```

         > material 변수의 자료형을 Object로 선언한 ThreeDPrinter에 파우더를 재료로 사용하기

        ```java
        ThreeDPrinter printer = new ThreeDPrinter();

        Powder p1 = new Powder();
        printer.setMaterial(p1); // 자동 형 변환 됨

        Powder p2 = (Powder)printer.getMaterial(); // 직접 형 변환을 해야 함
        ```

         - setMaterial() 메서드를 활용하여 Powder를 재료로 선택할 때는 매개변수 자료형이 Object이므로 자동으로 형 변환이 됨

         - 반환형이 Object 클래스인 getMaterial()메서드로 Powder 자료형 변수를 반환받을 때는 반드시 형 변환을 해주어야 함

         - 어떤 변수가 여러 참조 자료형을 사용할 수 있도록 Object 클래스를 사용하면 다시 원래 자료형으로 반환해주기 위해 매번 형 변환을 해야하는 번거로움이 있음

        → 이러한 경우 사용하는 프로그램 방식이 제네릭

        (여러 참조 자료형이 쓰일 수 있는 곳에 특정한 자료형을 지정하지 않고 클래스나 메서드를 정의한 후 사용하는 시점에 어떤 자료형을 사용할 것인지 지정하는 방식) 

    - 제네릭 클래스 정의하기

         - 제네릭에서는 여러 참조형을 사용해야 하는 부분에 Object가 아닌 하나의 문자로 표현함

         > ThreeDPrinter를 제네릭 클래스로 정의하기

        ```java
        public class GenericPrinter<T>{ // 제네릭 클래스
        	//T : type의 약자, 자료형 매개변수
        	private T material;

        	public void setMaterial(T material){
        		this.material = material;
        	}
        	public T getMaterial(){
        		return material;
        	}
        }
        ```

         - T : 자료형 매개변수(type parameter) 

         - 클래스의 이름을 GenericPrinter<T>라고 정의하고 나중에 클래스를 사용할 때 T의 위치에 실제 사용할 자료형을 지정

         - 다이아몬드 연산자 <>

        → 생성 부분에선 생략 가능

        ```java
        ArrrayList<String> list = new ArrayList<>(); // 생략 가능
        ```

         - 자료형 매개변수 T와 static

        static 변수나 메서드는 인스턴스를 생성하지 않아도 클래스 이름으로 호출할 수 있음

        static 변수는 인스턴스 변수가 생성되기 이전에 생성됨

        static 메서드에서는 인스턴스 변수를 사용할 수 없음

        → T 자료형이 정해지는 순간은 제네릭 클래스의 인스턴스가 생성되는 순간

        T의 자료형이 결정되는 시점보다 빠르기 때문에 static 변수의 자료형이나 static 메서드 내부 변수의 자료형으로 T를 사용할 수 없음

         - 제네릭에서 자료형 추론하기

        ```java
        var list = new ArrayList<String>();
        //ArrayList<String> list = new ArrayList<String>();
        ```

    - 제네릭 클래스 사용하기

         > 파우더가 재료인 프린터 선언하고 생성하기

        ```java
        GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
        powderPrinter.setMaterial(new Powder());
        Powder powder = powderPrinter.getMaterial(); // 명시적 형 변환을 하지 않음 ****
        ```

         → T로 정의한 부분에 Powder형을 넣어주고 T형 매개변수가 필요한 메서드에 Powder 클래스를 생성하여 대입해줌

        GenericPrinter<Powder>에서 어떤 자료형을 사용할 지 명시했으므로 getMaterial() 메서드에서 반환할때 형 변환을 하지 않음

        **GenericPrinter<Powder>** : 제네릭 자료형(Generic type) , 매개변수화된 자료형(parameterized type)

        **Powder** : 대입된 자료형

         > 플라스틱 액체가 재료인 프린터를 선언하기

        ```java
        GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
        plasticPrinter.setMaterial(new Plastic());
        Plastic plastic = plasticPrinter.getMaterial();
        ```

         - 제네릭 클래스 사용 예제

         > Powder 클래스 정의하기

        ```java
        package generics;

        public class Powder {
          public void doPrinting() {
            System.out.println("Powder 재료로 출력합니다.");
          }

          public String toString() {
            return "재료는 Powder 입니다.";
          }
        }
        ```

         > Plastic 클래스 정의하기

        ```java
        package generics;

        public class Plastic {
          public void doPrinting() {
            System.out.println("Plastic 재료로 출력합니다.");
          }

          public String toString() {
            return "재료는 Plastic 입니다.";
          }
        }
        ```

         > GenericPrinter<T> 클래스 정의하기

        ```java
        package generics;

        public class GenericPrinter<T> {
          private T material; // T 자료형으로 선언한 변수

          public void setMaterial(T material) {
            this.material = material;
          }

          // T 자료형 변수 material을 반환하는 제네릭 메서드
          public T getMaterial() {
            return material;
          }
          public String toString(){
            return material.toString();
          }
        }
        ```

         > GenericPrinter<T> 클래스 사용하기

        ```java
        package generics;

        public class GenericPrinterTest {
          public static void main(String[] args) {
            // Powder형으로 GenericPrinter 클래스 생성
            GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();

            powderPrinter.setMaterial(new Powder());
            Powder powder = powderPrinter.getMaterial();
            System.out.println(powderPrinter); // 재료는 Powder 입니다.

            // Plastic형으로 GenericPrinter 클래스 생성
            GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();

            plasticPrinter.setMaterial(new Plastic());
            Plastic plastic = plasticPrinter.getMaterial();
            System.out.println(plasticPrinter); // 재료는 Plastic 입니다.
          }
        }
        ```

         → 새로운 재료가 추가되면 추가된 재료 클래스를 만들고 T 대신 해당 클래스를 대입하여 GenericPrinter를 생성하면 됨

         - 제네릭에서 대입된 자료형을 명시하지 않는 경우 → 노란색 경고줄이 뜸

        ```java
        GenericPrinter powderPrinter2 = new GenericPrinter ();
        	//대입된 자료형 <Powder>을 명시하지 않음
        powderPrinter2.setMaterial(new Powder());
        Powder powder = (Powder)powderPrinter.getMaterial(); // 강제 형 변환
        System.out.println(powderPrinter);
        ```

        → 제네릭 클래스를 사용하는 경우에는 되도록이면 대입된 자료형으로 사용할 참조 자료형을 지정하는 것이 좋음

    - T 자료형에 사용할 자료형을 제한하는 <T extends 클래스>

         - 사용할 클래스에 자료형 제한을 두는 방식으로 extends 예약어를 사용함

         > Material 추상 클래스

        ```java
        package generics;

        public abstract class Material {
          // doPainting() 추상 메서드를 반드시 구현해야 함
          public abstract void doPrinting();
        }
        ```

         > Powder 클래스

        ```java
        package generics;

        public class Powder extends Material {
          public void doPrinting() {
            System.out.println("Powder 재료로 출력합니다.");
          }

          public String toString() {
            return "재료는 Powder 입니다.";
          }
        }
        ```

         > Plastic 클래스

        ```java
        package generics;

        public class Plastic extends Material {
          public void doPrinting() {
            System.out.println("Plastic 재료로 출력합니다.");
          }

          public String toString() {
            return "재료는 Plastic 입니다.";
          }
        }
        ```

         > GenericPrinter<T extends Material> 클래스

        ```java
        package generics;

        //extends 예약어로 사용할 수 있는 자료형에 제한을 둠
        public class GenericPrinter<T extends Material> {
          private T material; // T 자료형으로 선언한 변수

          public void setMaterial(T material) {
            this.material = material;
          }

          // T 자료형 변수 material을 반환하는 제네릭 메서드
          public T getMaterial() {
            return material;
          }

          public String toString() {
            return material.toString();
          }
        }
        ```

        → 만약 Material 클래스를 상속받지 않은 Water 클래스를 사용하면 오류가 발생

         - <T extends 클래스>로 상위 클래스 메서드 사용하기

        <T extends 클래스>로 선언하면 제네릭 클래스를 사용할 때 상위 클래스 Material에서 선언한 메서드를 모두 사용할 수도 있음

         > <T extends 클래스> 사용하기

        ```java
        package generics;

        //extends 예약어로 사용할 수 있는 자료형에 제한을 둠
        public class GenericPrinter<T extends Material> {
          private T material; // T 자료형으로 선언한 변수

          public void setMaterial(T material) {
            this.material = material;
          }

          // T 자료형 변수 material을 반환하는 제네릭 메서드
          public T getMaterial() {
            return material;
          }

          public String toString() {
            return material.toString();
          }

          public void printing() {
            material.doPrinting(); // 상위 클래스 Material의 메서드 호출
          }
        }
        ```

         > <T extends 클래스> 테스트하기

        ```java
        package generics;

        public class GenericPrinterTest2 {
          public static void main(String[] args) {
            GenericPrinter<Powder> powderPrinter = new GenericPrinter<Powder>();
            powderPrinter.setMaterial((new Powder()));
            powderPrinter.printing(); // Powder 재료로 출력합니다.

            GenericPrinter<Plastic> plasticPrinter = new GenericPrinter<Plastic>();
            plasticPrinter.setMaterial((new Plastic()));
            plasticPrinter.printing(); // Plastic 재료로 출력합니다.
          }
        }
        ```

    - 제네릭 메서드 활용하기

         - 제네릭 메서드의 일반 형식

        ```java
        public <자료형매개변수> 반환형 메서드이름(자료형 매개변수...){} 
        ```

        → 반환형 앞에 사용하는 <자료형 매개변수>는 여러개일 수 있으며 이는 메서드 내에서만 유효함

         > 자료형 매개변수를 두 개 사용하는 클래스

        ```java
        package generics;

        public class Point<T, V> {
          // 멤버변수
          T x;
          V y;

          // 생성자
          Point(T x, V y) {
            this.x = x;
            this.y = y;
          }

          // 제네릭 메소드
          public T getX() {
            return x;
          }

          public V getY() {
            return y;
          }
        }
        ```

         > 제네릭 메서드 구현하기

        ```java
        package generics;

        public class GenericMethod { //제네릭 클래스가 아니지만 내부에 제네릭 메서드 구현 가능
          // 두 점은 Integer 형으로 만들어질 수도 있고 double형으로 만들어질 수도 있음
          public static <T, V> double makeRectangle(Point<T, V> p1, Point<T, V> p2) {// 제네릭 메서드
            double left = ((Number) p1.getX()).doubleValue();
            double right = ((Number) p2.getX()).doubleValue();
            double top = ((Number) p1.getY()).doubleValue();
            double bottom = ((Number) p2.getY()).doubleValue();

            double width = right - left;
            double height = bottom - top;

            return width * height;
          }

          public static void main(String[] args) {
            Point<Integer, Double> p1 = new Point<Integer, Double>(0, 0.0);
            Point<Integer, Double> p2 = new Point<Integer, Double>(10, 10.0);

            double rect = GenericMethod.<Integer, Double>makeRectangle(p1, p2);
            System.out.println("두 점으로 만들어진 사각형의 넓이는 " + rect + "입니다.");
          }
        }
        ```

    - 컬렉션 프레임워크에서 사용하는 제네릭

         - ArrayList

        → 배열은 요소를 가지므로 T보다는 Element를 의미하는 E를 더 많이 사용

        ```java
        ArrayList<String> list = new ArrayList<String>();
        ```

         → 컴파일러가 형 변환을 구현하므로 프로그래머가 직접 형 변환을 하지 않아도 됨

        ```java
        ArrayList<String> list = new ArrayList<String>();
        String str = new String("abc");
        list.add(str);
        String s = list.get(0); // 형 변환을 사용하지 않음
        ```

2. 컬렉션 프레임워크(collection framework)
    - 컬렉션 프레임워크란?

         - 컬렉션 프레임워크 : 자바에서는 필요한 자료 구조(data structure)를 미리 구현하여 java.util 패키지에서 제공하고 있음

         - 자료구조 : 프로그램의 기능을 효과적으로 구현하기 위해 사용하는 것

        → 개발자가 필요할때 직접 만들어서 사용할 수 있지만 자바 컬렉션 프레임워크를 사용하면 직접 개발하는 수고를 덜 수 잇을 뿐만 아니라 잘 만들어진 자료구조 클래스를 활용할 수 있음

         - 컬렉션 프레임워크의 전체 구조

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fa99c7d-808e-44d9-a237-3f383a31a64e/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fa99c7d-808e-44d9-a237-3f383a31a64e/Untitled.png)

         → Collection 인터페이스 : 하나의 자료를 모아서 관리하는데 필요한 기능을 제공

         → Map 인터페이스 : 쌍(pair)으로 된 자료들을 관리하는데 유용한 기능을 제공

    - Collection 인터페이스

         - List 인터페이스 : 순차적인 자료를 관리하는데 사용

        순서가 있는 자료를 관리, 중복 허용

        ArrayList, Vector, LinkedList, Stack, Queue 등

         - Set 인터페이스 : 집합(순서와 상관없이 중복을 허용하지 않음)

        순서가 정해져 있지 않음, 중복을 허용하지 않음

        HashSet, TreeSet

         - 자주 사용하는 메서드

        **boolean add(E e)**

        : Collection에 객체를 추가함

        **Void clear()**

        : Collection의 모든 객체를 제거

        **Iterator<E> iterator**

        : Collection을 순환할 반복자(Iterator)를 반환

        **boolean remove(Object o)**

        : Collection에 매개변수에 해당하는 인스턴스가 존재하면 제거

        **int size()**

        : Collection에 있는 요소의 개수를 반환

    - Map 인터페이스

         - key-value 쌍 : key값은 중복될 수 없음

         - 검색용 자료구조 : 어떤 key값을 알고 있을 때 value를 찾기 위한 자료구조

         - 주요 메서드

        **V put(K key, V value)**

        : key에 해당하는 value 값을 map에 넣음

        **V get(K key)**

        : key에 해당하는 value 값을 반환

        **boolean isEmpty()**

        : Map이 비었는지 여부를 반환

        **boolean containsKey(Object key)**

         : MAP에 해당 key가 있는지 여부를 반환

        **boolean containsValue(Object value)**

        : MAP에 해당 value가 있는지 여부를 반환

        **Set keyset()**

        : key 집합을 Set로 반환(중복이 안되므로 Set)

        **Collection values()**

        : value를 Collection으로 반환(중복 무관)

        **V remove(key)**

        : key가 있는 경우 삭제

        **boolean remove(Object key, Object value)**

        : key가 있는 경우 key에 해당하는 value가 매개 변수와 일치할때 삭제

    - 실습 패키지 구조

         - 계층적으로 패키지 구조를 잡아서 소스 코드 파일 구분하여 사용하기

         - collection 패키지 하위에 프로그램 전반에서 공통으로 사용할 '회원'을 나타내는 Member 클래스 만들기

        ```java
        package collection;

        import Object.ToStringEx;

        public class Member {
          // 멤버변수 - 속성
          private int memberId; // 회원 아이디
          private String memberName; // 회원 이름

          // 생성자 - 초기화
          public Member(int memberId, String memberName) {
            this.memberId = memberId;
            this.memberName = memberName;
          }

          // 변수를 private로 선언했기 때문에 get, set메소드 생성
          public int getMemberId() {
            return memberId;
          }

          public void setMemberId(int memberId) {
            this.memberId = memberId;
          }

          public String getMemberName() {
            return memberName;
          }

          public void setMemberName(String memberName) {
            this.memberName = memberName;
          }

          // toString() 메소드 재정의하기
          @Override
          public String toString() {
            return memberName + " 회원님의 아이디는 " + memberId + "입니다";
          }
        }
        ```

3. List 인터페이스
    - ArrayList 클래스

         - 객체 배열을 구현한 클래스

        객체 순서를 기반으로 순차적으로 자료를 관리하는 프로그램을 구현할 때 사용

         - ArrayList를 활용해 회원 관리 프로그램 구현하기

         → 회원 추가 : addMember() 메서드

        회원 삭제 : removeMember() 메서드

        전체 회원 출력 : showAllMember() 메서드

         > ArrayList 활용하기

        ```java
        package collection.arraylist;

        import java.util.ArrayList; // ArrayList 사용하기 위해서 선언
        import collection.Member;

        public class MemberArrayList {
        	// ===멤버 변수===
        	// 자료형이 Member인 ArraayList 선언
        	private ArrayList<Member> arrayList;

        	// ===생성자===
        	// Member형으로 선언한 ArrayList생성
        	public MemberArrayList() {
        		arrayList = new ArrayList<Member>();
        	}

        	// ===메소드===
        	// ArrayList에 회원을 추가하는 메서드
        	// 매개변수로 전달된 회원을 ArrayList 맨 뒤에 추가
        	public void addMember(Member member) {
        		arrayList.add(member);
        	}

        	// 해당 아이디를 가진 회원을 ArrayList에서 찾아 제거함
        	public boolean removeMember(int memberId) {
        		for (int i = 0; i < arrayList.size(); i++) {
        			// get() 메서드로 회원을 순차적으로 가져옴
        			Member member = arrayList.get(i);
        			int tempId = member.getMemberId(); // 임시로 비교대상 memberId 생성
        			if (tempId == memberId) { // 회원 아이디가 매개 변수와 일치하면
        				arrayList.remove(i); // 해당 회원을 삭제
        				return true;
        			}
        		}
        		// 반복문이 끝날 때까지 해당 아이디를 찾지 못한 경우
        		System.out.println(memberId + "가 존재하지 않습니다.");
        		return false;
        	}

        	// 전체 회원을 출력하는 메서드
        	public void showAllMember() {
        		for (Member member : arrayList) {
        			System.out.println(member); // arrayList에 있는 member 하나씩 출력
        		}
        		System.out.println(); // 줄바꿈
        	}
        }
        ```

         - MemberArrayList 테스트 클래스 구현하기

        ```java
        package collection.arraylist;

        import collection.Member;

        public class MemberArrayListTest {
        	public static void main(String[] args) {
        		MemberArrayList memberArrayList = new MemberArrayList(); // 객체 생성 후 memberArrayList 변수에 대입
        		// 새로운 회원 인스턴스 생성
        		Member memberLee = new Member(1001, "이지원");
        		Member memberSon = new Member(1002, "손민국");
        		Member memberPark = new Member(1003, "박서훤");
        		Member memberHong = new Member(1004, "홍길동");

        		// ArrayList에 회원 추가
        		memberArrayList.addMember(memberLee);
        		memberArrayList.addMember(memberSon);
        		memberArrayList.addMember(memberPark);
        		memberArrayList.addMember(memberHong);

        		// 전체 회원 출력
        		memberArrayList.showAllMember();
        		// 홍길동 회원삭제
        		memberArrayList.removeMember(memberHong.getMemberId());
        		// 홍길동 회원을 삭제 한 후 다시 전체 회원 출력
        		memberArrayList.showAllMember();
        	}

        }
        ```

    - ArrayList와 Vector 클래스

        Vector : 동기화(synchronization) 지원

         - 동기화 : 두 개 이상의 스레드가 동시에 Vector를 사용할 때 오류가 나지 않도록 실행 순서를 보장하는 것

         - 스레드와 멀티스레드 프로그래밍

        스레드 : 작업 단위, 프로그램이 메모리에서 수행되려면 스레드 작업이 생성되어야 함

        단일 스레드 : 하나의 스레드만 수행됨 → ArrayList를 사용하도록 권장

        멀티 스레드 : 두 개 이상의 스레드가 동시에 실행되는 경우

        두 개 이상의 스레드가 동시에 실행되면 같은 메모리 공간에 접근하기 때문에 변수 값이나 메모리 상태에 오류가 생길 수 있음, 이 때 메모리에 동시에 접근하지 못하도록 순서를 맞추는 것이 동기화

         - Vector의 모든 메서드는 호출될 때마다 잠금과 해제가 일어나므로 ArrayList보다 수행 속도가 느림

         - ArrayList를 사용해서 구현했는데 나중에 프로그램에서 동기화가 필요하다면 Vector로 바꾸지 않고 다음과 같이 ArrayList생성 코드 사용

        ```java
        Collections.synchronizedList(new ArrayList<String>());
        ```

    - LinkedList 클래스

         - 배열은 처음 배열을 생성할 때 정적 크기로 선언하고 물리적 순서와 논리적 순서가 동일

        처음 선언한 배열 크기 이상으로 요소가 추가되는 경우에 크기가 더 큰 배열을 생성하여 각 요소를 복사해야하는 번거로움이 있음

        → 이를 개선한 자료구조 : 링크드 리스트(linked list)

         - 링크드 리스트 구조

        링크드 리스트의 각 요소는 다음 요소를 가리키는 주소값을 가짐

        → 물리적인 메모리는 떨어져 있어도 논리적으로 앞 뒤 순서가 있음

        ArrayList에 비해 중간에 자료를 넣고 제거하는데 시간이 적게 걸리는 장점이 있음

         - 링크드 리스트에 요소 추가하기

        서로 가리키고 있는 주소값만 변경해주면 됨

         - 링크드 리스트 요소 제거하기

        각 요소가 가리키는 주소값만 변경해주면 됨

        제거된 메모리는 나중에 자바의 가비지 컬렉터에 의해 수거됨

         - 배열과 링크드 리스트의 다른점

        링크드리스트는 요소를 추가할때마다 동적으로 요소의 메모리를 생성하기때문에 배열처럼 용량을 늘리고 요소 값을 복사하는 번거로움이 없음

        ⇒ 사용하는 자료의 변동(삽입, 삭제)이 많은 경우에는 링크드 리스트를 사용하는 것이 효율적

        자료 변동이 거의 없는 경우에는 배열을 사용하는 것이 효율적

         - LinkedList 클래스 사용하기

        LinkedList는 ArrayList보다 다양한 메서드를 제공

         > LinkedList 테스트하기

        ```java
        package collection;

        import java.util.LinkedList;

        public class LinkedListTest {

        	public static void main(String[] args) {
        		// LinkedList 객체 생성
        		LinkedList<String> myList = new LinkedList<String>();

        		// 링크드 리스트에 요소 추가
        		myList.add("A");
        		myList.add("B");
        		myList.add("C");
        		// 리스트 전체 출력
        		System.out.println(myList); // [A, B, C]

        		// 링크드 리스트의 첫번째 위치에 D 추가
        		myList.add(1, "D");
        		System.out.println(myList); // [A, D, B, C]

        		// 링크드 리스트의 맨 앞에 0 추가
        		myList.addFirst("0");
        		System.out.println(myList); // [0, A, D, B, C]

        		// 링크드 리스트의 맨 뒤 요소 삭제 후 해당 요소를 출력
        		System.out.println(myList.removeLast()); // C
        		System.out.println(myList); // [0, A, D, B]
        	}
        }
        ```

    - ArrayList로 스택과 큐 구현하기

         - 스택(stack) : 상자를 쌓듯이 자료를 관리하는 방식, 맨 나중에 올린 상자를 먼저 꺼내야 함

        LIFO(Last In First Out) : 맨 나중에 추가된 데이터를 먼저 꺼내는 방식

         - 큐(Queue) : 선착순

        FIFO(First In First Out) : 먼저 추가된 데이터부터 꺼내서 사용하는 방식

         - ArrayList로 스택 구현하기

        push() : 스택에 자료 추가

        pop() : 자료를 꺼내기

         > 스택 구현하기

        ```java
        package collection.arraylist;

        import java.util.ArrayList;

        class MyStack {
        	private ArrayList<String> arrayStack = new ArrayList<String>();

        	// 스택의 맨 뒤에 요소를 추가
        	public void push(String data) {
        		arrayStack.add(data);
        	}

        	// 스택의 맨 뒤에서 요소 꺼냄
        	public String pop() {
        		// ArrayList에 저장된 유효한 자료의 개수
        		int len = arrayStack.size();
        		if (len == 0) {
        			System.out.println("스택이 비었습니다.");
        			return null;
        		}
        		// 맨 뒤에 있는 자료 반환하고 배열에서 제거
        		return arrayStack.remove(len - 1);
        	}
        }

        public class StackTest {
        	public static void main(String[] args) {
        		// MyStack 객체 생성
        		MyStack stack = new MyStack();
        		// stack에 데이터 넣기
        		stack.push("A");
        		stack.push("B");
        		stack.push("C");

        		System.out.println(stack.pop()); // C
        		System.out.println(stack.pop()); // B
        		System.out.println(stack.pop()); // A
        	}
        }
        ```

         - ArrayList로 큐 구현하기

         > 큐 구현하기

        ```java
        package collection.arraylist;

        import java.util.ArrayList;

        class MyQueue {
        	private ArrayList<String> arrayQueue = new ArrayList<String>();

        	// 큐의 맨 뒤에 추가
        	public void enQueue(String data) {
        		arrayQueue.add(data);
        	}

        	// 큐의 맨 앞에서 꺼냄
        	public String deQueue() {
        		int len = arrayQueue.size();
        		if (len == 0) {
        			System.out.println("큐가 비었습니다");
        			return null;
        		}
        		// 맨 앞의 자료 반환하고 배열에서 제거
        		return (arrayQueue.remove(0));
        	}
        }

        public class QueueTest {
        	public static void main(String[] args) {
        		MyQueue queue = new MyQueue();
        		queue.enQueue("A");
        		queue.enQueue("B");
        		queue.enQueue("C");

        		System.out.println(queue.deQueue()); // A
        		System.out.println(queue.deQueue()); // B
        		System.out.println(queue.deQueue()); // C
        	}
        }
        ```

    - Collection 요소를 순회하는 Iterator

         - 순서가 없는 Set 인터페이스를 구현한 경우에는 get(i) 메서드를 사용할 수 없음

        → Iterator 사용 : Collection 인터페이스를 구현한 객체에서 미리 정의되어 있는 iterator()메서드를 호출하여 참조

        ```java
        Iterator ir = memberArrayList.iterator();
        ```

         : Iterator 형 변수에 대입하여 사용

         - Iterator를 사용하여 요소를 순회할때 사용하는 메서드

        **boolean hashNext()**

        : 이후에 요소가 더 있는지를 체크하는 메서드, 요소가 있다면 true를 반환

        **E next()** 

        : 다음에 있는 요소를 반환

         > MemberArrayList 클래스의 removeMember() 메서드를 수정

        ```java
        // 해당 아이디를 가진 회원을 ArrayList에서 찾아 제거함
        	public boolean removeMember(int memberId) {
        		Iterator<Member> ir = arrayList.iterator(); // iterator 반환
        		while(ir.hashNext()){ //다음 요소가 있는 동안
        			Member member = ir.next(); // 다음 회원을 반환받음
        			int tempId = member.getMemberId(); // 비교대상 Id 받아옴
        			if(tempId == memberId){ // 회원 아이디가 매개 변수와 일치하면
        				arrayList.remove(member); // 해당 회원 삭제
        				return true; // true 반환
        			}
        		}
        	// 끝날 때까지 삭제하려는 값을 찾지 못한 경우
        	System.out.println(memberID+"가 존재하지 않습니다.");
        	return false;
        	}
        ```

        → 순서가 없는 클래스도 Iterator를 사용하면 요소를 순회할 수 있음

4. Set 인터페이스

     - 순서와 상관없이 중복을 허락하지 않는 경우

    (회원 아이디, 주민등록번호, 사번, 홈쇼핑 주문 번호)

    - HashSet 클래스

         - 집합 자료 구조를 구현하며 중복을 허용하지 않음

         > HashSet 테스트하기

        ```java
        package collection.hashset;

        import java.util.HashSet;

        public class HashSetTest {
        	public static void main(String[] args) {
        		HashSet<String> hashSet = new HashSet<String>();
        		hashSet.add(new String("임정순"));
        		hashSet.add(new String("박현정"));
        		hashSet.add(new String("홍연의"));
        		hashSet.add(new String("강감찬"));
        		hashSet.add(new String("강감찬"));

        		System.out.println(hashSet); // [홍연의, 박현정, 강감찬, 임정순]
        	}
        }
        ```

        → 같은 자료는 중복되어 출력되지 않음, 추가된 순서와 상관없이 출력됨

         - HashSet를 활용해 회원 관리 프로그램 구현하기

         > HashSet 활용하기

        ```java
        package collection.hashset;

        import java.util.HashSet;
        import java.util.Iterator;
        import collection.Member;

        public class MemberHashSet {
          private HashSet<Member> hashSet; // HashSet 선언

          public MemberHashSet() {
            hashSet = new HashSet<Member>(); // HashSet 생성
          }

          // HashSet에 회원 추가
          public void addMember(Member member) {
            hashSet.add(member);
          }

          // 매개 변수로 받은 회원 아이디에 해당하는 회원 삭제
          public boolean removeMember(int memberId) {
            // Iterator를 활용해 순회함
            Iterator<Member> ir = hashSet.iterator();
            while (ir.hasNext()) { // 다음 요소가 존재할 때까지
              Member member = ir.next(); // 회원을 하나씩 가져와서
              int tempId = member.getMemberId(); // 아이디 비교대상
              if (tempId == memberId) { // 같은 아이디인 경우
                hashSet.remove(member); // 회원 삭제
                return true;
              }
            }
            System.out.println(memberId + "가 존재하지 않습니다.");
            return false;
          }
        	// 모든 회원 출력
          public void showAllMember() {
            for (Member member : hashSet) {
              System.out.println(member);
            }
            System.out.println();
          }
        }
        ```

         - HashSet의 메서드

        **boolean remove(Object o)**

        : 매개변수로 받은 객체를 삭제하고 삭제 여부를 true, false로 반환

         > Hash Set 활용하기

        ```java
        package collection.hashset;

        import collection.Member;

        public class MemberHashSetTest {
        	public static void main(String[] args) {
        		MemberHashSet memberHashSet = new MemberHashSet();

        		// 새로운 회원 인스턴스 생성
        		Member memberLee = new Member(1001, "이지원");
        		Member memberSon = new Member(1002, "손민국");
        		Member memberPark = new Member(1003, "박서훤");

        		// 회원들을 HashSet애 추가
        		memberHashSet.addMember(memberLee);
        		memberHashSet.addMember(memberSon);
        		memberHashSet.addMember(memberPark);
        		memberHashSet.showAllMember();

        		// 아이디 중복 회원 추가
        		Member memberHong = new Member(1003, "홍길동");
        		memberHashSet.addMember(memberHong);
        		memberHashSet.showAllMember();
        	}

        }
        ```

         → Member 클래스에도 같은 객체를 처리하는 방법을 구현해 사용하기

         - 객체가 동일함을 구현하기

        인스턴스 주소가 같으면 같은 객체, 회원 아이디가 같아도 같은 회원

        → equals()메서드와 hashCode()메서드 재정의하기

         > HashSet 활용하기

        ```java
        package collection;

        public class Member {
          // 멤버변수 - 속성
          private int memberId; // 회원 아이디
          private String memberName; // 회원 이름

          // 생성자 - 초기화
          public Member(int memberId, String memberName) {
            this.memberId = memberId;
            this.memberName = memberName;
          }

          // 변수를 private로 선언했기 때문에 get, set메소드 생성
          public int getMemberId() {
            return memberId;
          }

          public void setMemberId(int memberId) {
            this.memberId = memberId;
          }

          public String getMemberName() {
            return memberName;
          }

          public void setMemberName(String memberName) {
            this.memberName = memberName;
          }

          // toString() 메소드 재정의하기
          @Override
          public String toString() {
            return memberName + " 회원님의 아이디는 " + memberId + "입니다";
          }

          // hashCode()메서드가 회원 아이디를 반환하도록 재정의
          @Override
          public int hashCode() {
            return memberId;
          }

          // 매개변수로 받은 회원 아이디가 자신의 회원 아이디와 같다면 true 반환 하도록 재정의
          @Override
          public boolean equals(Object obj) {
            if (obj instanceof Member) { // obj가 Member의 인스턴스이면
              Member member = (Member) obj; // obj를 Member로 명시적 형변환
              if (this.memberId == member.memberId)
                return true;
              else
                return false;
            }
            return false;
          }
        }
        ```

    - TreeSet 클래스

         - 자료의 중복을 허용하지 않으면서 출력 결과 값을 정렬하는 클래스

         > TreeSet 테스트 하기

        ```java
        package collection.treeset;

        import java.util.TreeSet;

        public class TreeSetTest {
        	public static void main(String[] args) {
        		TreeSet<String> treeSet = new TreeSet<String>();
        		treeSet.add("홍길동");
        		treeSet.add("강감찬");
        		treeSet.add("이순신");

        		for (String str : treeSet) {
        			System.out.println(str); //강감찬 이순신 홍길동
        		}
        	}
        }
        ```

         - 이진 검색 트리(Binary Search Tree:BST)

        부모-자식 노드에서 노드에 저장되는 자료의 중복을 허용하지 않고 부모가 가지는 자식 노드의 수가 2개 이하임

        왼쪽에 위치하는 자식 노드는 부모 노드보다 항상 작은 값을 가짐, 오른쪽에 놓인 자식 노드는 부모 노드보다 항상 큰 값을 가짐

        비교 범위가 평균 1/2만큼씩 줄어들어 효과적으로 자료를 검색할 수 있음

        왼쪽→부모→오른쪽 순으로 순회하면 오름차순이 됨

         - TreeSet를 활용해 회원 관리 프로그램 구현하기

         > TreeSet 활용하기

        ```java
        package collection.treeset;

        import java.util.Iterator;
        import java.util.TreeSet;
        import collection.Member;

        public class MemberTreeSet {
          // 멤버 변수
          private TreeSet<Member> treeSet;

          // 생성자
          public MemberTreeSet() {
            treeSet = new TreeSet<Member>();
          }

          // 메소드
          // TreeSet에 회원을 추가하는 메서드
          public void addMember(Member member) {
            treeSet.add(member);
          }

          // TreeSet에서 회원을 삭제하는 메서드
          public boolean removeMember(int memberId) {
            Iterator<Member> ir = treeSet.iterator();

            while (ir.hasNext()) {
              Member member = ir.next();
              int tempId = member.getMemberId();
              if (tempId == memberId) {
                treeSet.remove(member);
                return true;
              }
            }
            System.out.println(memberId + "가 존재하지 않습니다.");
            return false;
          }

          public void showAllMember() {
            for (Member member : treeSet) {
              System.out.println(member);
            }
            System.out.println();
          }
        }
        ```

         > TreeSet 테스트하기

        ```java
        package collection.treeset;

        import collection.Member;

        public class MemberTreeSetTest {
        	public static void main(String[] args) {
        		MemberTreeSet memberTreeSet = new MemberTreeSet();

        		Member memberLee = new Member(1001, "이지원");
        		Member memberSon = new Member(1002, "손민국");
        		Member memberPark = new Member(1003, "박서훤");

        		memberTreeSet.addMember(memberLee);
        		memberTreeSet.addMember(memberSon);
        		memberTreeSet.addMember(memberPark);
        		memberTreeSet.showAllMember();

        		// 아이디 중복 회원 추가
        		Member memberHong = new Member(1003, "홍길동");
        		memberTreeSet.addMember(memberHong);
        		memberTreeSet.showAllMember();
        	}
        }
        ```

        → 오류 발생 : Member 클래스가 Comparable 인터페이스를 구현하지 않았다는 의미

        인터페이스 Comparable/ Comparator : 어떤 기준으로 비교할 것인지 구현해야 함

    - Comparable 인터페이스와 Comparator 인터페이스

         - 정렬 기준 값이 있는 Member 클래스에 구현

        ```java
        public class Member implements Comparable<member>{
        	...
        }
        ```

         - 자기 자신과 전달받은 매개 변수를 비교하는 **Comparable** 인터페이스 → 더욱 많이 사용됨

        Comparable 인터페이스에는 compareTo() 추상메서드가 포함되어 있기 때문에 이 인터페이스를 구현하는 Member 클래스에서 compareTo() 메서드를 구현해야 함

         > Comparable 인터페이스 구현하기(오름차순 정렬)

        ```java
        package collection;

        public class Member implements Comparable<Member> {
          // 멤버변수 - 속성
          private int memberId; // 회원 아이디
          private String memberName; // 회원 이름

          // 생성자 - 초기화
          public Member(int memberId, String memberName) {
            this.memberId = memberId;
            this.memberName = memberName;
          }
        ...
          // compareTo() 메서드 재정의
          // 추가한 회원 아이디와 매개변수로 받은 회원 아이디를 비교함
          @Override
          public int compareTo(Member member) {
            return (this.memberId - member.memberId);
          }
        }
        ```

        → 새로 추가한 회원의 아이디와 compareTo() 메서드의 매개변수로 전달된 회원 아이디를 비교하여 새로 추가한 회원 아이디가 더 크면 양수, 그렇지 않으면 음수, 같으면 0을 반환하도록 함 : 오름차순으로 정렬됨

         > 내림차순 정렬

        ```java
        @Override
        public int compareTo(Member member){
        	return (this.memberID-member.memberID)*(-1)
        }// 반환 값을 음수로 만듦
        ```

         - 두 매개변수를 비교하는 **Comparator** 인터페이스

        Comparable 인터페이스에는 compare() 추상메서드가 포함되어 있기 때문에 이 인터페이스를 구현하는 Member 클래스에서 compare() 메서드를 구현해야 함

          > Comparator 인터페이스 구현하기

        ```java
        package collection;

        import java.util.Comparator;

        public class Member2 implements Comparator<Member2> {
        	// 멤버변수 - 속성
        	private int memberId; // 회원 아이디
        	private String memberName; // 회원 이름

        	// 생성자 - 초기화
        	public Member2(int memberId, String memberName) {
        		this.memberId = memberId;
        		this.memberName = memberName;
        	}

        	// 변수를 private로 선언했기 때문에 get, set메소드 생성
        	public int getMemberId() {
        		return memberId;
        	}

        	public void setMemberId(int memberId) {
        		this.memberId = memberId;
        	}

        	public String getMemberName() {
        		return memberName;
        	}

        	public void setMemberName(String memberName) {
        		this.memberName = memberName;
        	}

        	// toString() 메소드 재정의하기
        	@Override
        	public String toString() {
        		return memberName + " 회원님의 아이디는 " + memberId + "입니다";
        	}

        	// hashCode()메서드가 회원 아이디를 반환하도록 재정의
        	@Override
        	public int hashCode() {
        		return memberId;
        	}

        	// 매개변수로 받은 회원 아이디가 자신의 회원 아이디와 같다면 true 반환 하도록 재정의
        	@Override
        	public boolean equals(Object obj) {
        		if (obj instanceof Member) { // obj가 Member의 인스턴스이면
        			Member member = (Member) obj; // obj를 Member로 명시적 형변환
        			if (this.memberId == member.getMemberId())
        				return true;
        			else
        				return false;
        		}
        		return false;
        	}

        	// compare()메서드 재정의.
        	// 전달받은 두 매개변수를 비교함
        	@Override
        	public int compare(Member2 mem1, Member2 mem2) {
        		return mem1.getMemberId() - mem2.getMemberId();
        	}
        }
        ```

        → 첫번째 매개변수가 더 클 경우 양수를 반환하여 오름차순으로 정렬

        TreeSet 생성자에 Comparator를 구현한 객체를 매개변수로 전달

        ```java
        TreeSet<Member> treeSet = new TreeSet<Member>(new Member());
        ```

         - String 클래스는 Comparable 인터페이스를 이미 구현하여 compareTo() 메서드는 오름차순 정렬을 구현하고 있음

        만약 정렬 방식을 내림차순으로 바꾸고 싶은 경우

        → String클래스의 경우 final로 선언되어 있어서 상속받아 compareTo() 메서드를 재정의할 수 없음 : 이 경우 Comparator를 사용

         > Comparator 인터페이스 사용하기

        ```java
        package collection.treeset;

        import java.util.Comparator;
        import java.util.Set;
        import java.util.TreeSet;

        class MyCompare implements Comparator<String> {
          // 내림 차순 정렬로 재정의
          @Override
          public int compare(String s1, String s2) {
            return (s1.compareTo(s2)) * (-1);
          }
        }

        public class ComparatorTest {
          public static void main(String[] args) {
            // TreeSet 생성자의 매개 변수로 정렬 방식을 지정
            Set<String> set = new TreeSet<String>(new MyCompare());
            set.add("aaa");
            set.add("ccc");
            set.add("bbb");
            System.out.println(set); // [ccc, bbb, aaa]
          }
        }
        ```

        → 내림차순 정렬됨

5. Map 인터페이스

     - 자료를  쌍(pair)으로 관리하는데 필요한 메서드가 정의되어 있음

    key값은 유일하며 value 값은 중복될 수 있음

    - HashMap 클래스

         - Map 인터페이스를 구현한 클래스 중 가장 많이 사용

        → 해시방식으로 자료를 관리(해시 테이블에 저장)

         - 자료 추가 속도나 검색 속도가 상당히 빠름

         - Map 인터페이스에서 사용하는 key값은 중복될 수 없으므로 equals() 메서드와 hashcode() 메서드를 재정의하여 사용하는 것이 좋음

         - HashMap을 활용해 회원 관리 프로그램 구현하기

        key값은 회원 아이디, value 값은 회원 클래스로 구현

         > HashMap 활용하기

        ```java
        package map.hashmap;

        import java.util.HashMap;
        import java.util.Iterator;

        import collection.Member;

        public class MemberHashMap {
          // 멤버 변수
          private HashMap<Integer, Member> hashMap;

          // 생성자
          public MemberHashMap() {
            hashMap = new HashMap<Integer, Member>();
          }

          // HashMap에 회원을 추가하는 메서드
          public void addMember(Member member) {
            hashMap.put(member.getMemberId(), member); // key-value 쌍으로 추가
          }

          // HashMap에 회원을 삭제하는 메서드
          public boolean removeMember(int memberId) {
            if (hashMap.containsKey(memberId)) {
              // HashMap에 매개변수로 받은 키 값인 회원 아이디가 있다면
              hashMap.remove(memberId); // 해당 회원 삭제
              return true;
            }
            System.out.println(memberId + "가 존재하지 않습니다.");
            return false;
          }

          // Iterator를 사용해 전체 회원을 출력하는 메서드
          public void showAllMember() {
            Iterator<Integer> ir = hashMap.keySet().iterator(); // 모든 키 값이 Set 객체로 반환
            while (ir.hasNext()) { // 다음 key가 있으면
              int key = ir.next(); // key값을 가져와서
              Member member = hashMap.get(key); // key로부터 value 가져오기
              System.out.println(member);
            }
            System.out.println();
          }
        }
        ```

        → key는 중복될 수 없으므로 반환형이 Set, value는 중복 가능하므로 Collection

         > HashMap 활용하기

        ```java
        package map.hashmap;

        import collection.Member;

        public class MemberHashMapTest {
        	public static void main(String[] args) {
        		MemberHashMap memberHashMap = new MemberHashMap();

        		// 멤버 인스턴스 생성
        		Member memberLee = new Member(1001, "이지원");
        		Member memberSon = new Member(1002, "손민국");
        		Member memberPark = new Member(1003, "박서훤");
        		Member memberHong = new Member(1004, "홍길동");
        		// memberHashMap에 추가하기
        		memberHashMap.addMember(memberLee);
        		memberHashMap.addMember(memberSon);
        		memberHashMap.addMember(memberPark);
        		memberHashMap.addMember(memberHong);
        		memberHashMap.showAllMember();
        		memberHashMap.removeMember(1004); // 회원아이디(key 값)가 1004인 회원 삭제
        		memberHashMap.showAllMember();
        	}
        }
        ```

         - HashMap과 Hashtable

        : 모두 쌍으로 이루어진 자료를 관리하는데 사용

        Hashtable 클래스는 멀티 스레드를 위한 동기화를 제공

        멀티 스레드 환경이 아니라면 HashMap을 사용하는 것이 더 권장됨

    - TreeMap 클래스

         - Map 인터페이스를 구현한 클래스 중 key값으로 자료를 정렬하려면 TreeMap사용

         > TreeMap 활용하기

        ```java
        package map.treemap;

        import java.util.Iterator;
        import java.util.TreeMap;

        import collection.Member;

        public class MemberTreeMap {
          // 멤버 변수 선언
          private TreeMap<Integer, Member> treeMap;

          // 생성자
          public MemberTreeMap() {
            treeMap = new TreeMap<Integer, Member>();
          }

          // 추가 메서드
          public void addMember(Member member) {
            treeMap.put(member.getMemberId(), member); // Key-value 쌍으로 추가
          }

          // 제거 메서드
          public boolean removeMember(int memberId) {
            if (treeMap.containsKey(memberId)) {
              treeMap.remove(memberId); // key값에 맞는 자료 삭제
              return true;
            }
            System.out.println(memberId + "가 존재하지 않습니다.");
            return false;
          }

          // 전체 출력 메서드
          public void showAllMember() {
            Iterator<Integer> ir = treeMap.keySet().iterator();
            while (ir.hasNext()) {
              int key = ir.next();
              Member member = treeMap.get(key);
              System.out.println(member);
            }
            System.out.println();
          }
        }
        ```

         > TreeMap 활용하기

        ```java
        package map.treemap;

        import collection.Member;

        public class MemberTreeMapTest {
        	public static void main(String[] args) {
        		MemberTreeMap memberTreeMap = new MemberTreeMap();

        		// 멤버 인스턴스 생성
        		// 회원 아이디 순서와 상관 없이 회원 추가
        		Member memberPark = new Member(1003, "박서훤");
        		Member memberLee = new Member(1001, "이지원");
        		Member memberHong = new Member(1004, "홍길동");
        		Member memberSon = new Member(1002, "손민국");
        		// memberHashMap에 추가하기
        		memberTreeMap.addMember(memberLee);
        		memberTreeMap.addMember(memberSon);
        		memberTreeMap.addMember(memberPark);
        		memberTreeMap.addMember(memberHong);
        		memberTreeMap.showAllMember();
        		memberTreeMap.removeMember(1004); // 회원아이디(key 값)가 1004인 회원 삭제
        		memberTreeMap.showAllMember();
        	}
        }
        ```

6. 연습문제
    - 자료구조를 사용하기 편리하도록 자바에서 제공하는 라이브러리를 [컬렉션 프레임워크]라고 합니다.
    - 클래스에서 여러 자료형을 사용할 때 자료형을 명시하지 않고 자료형을 의미하는 문자로 선언한 후 실제 클래스를 생성할 때 자료형을 명시하는 프로그래밍 방식을 [제네릭 프로그래밍]이라고 합니다.
    - Collection 인터페이스를 구현한 클래스를 순회하기 위해 사용하는 인터페이스는 [Iterator]입니다.
    - TreeSet를 사용할 때 Comparable 인터페이스를 구현해야하는 이유

        → TreeSet 객체가 추가될 때 정렬되는 방식을 구현하기때문
