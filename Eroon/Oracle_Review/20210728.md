## Oracle 1~13

1. 데이터 베이스
    - **검색**이 용이하도록 일정한 기준에 맞추어 자료를 분류하여 정리해 놓은 **자료의 집합**

        (엑셀 자체는 데이터 베이스가 아니지만 잘 정리하면 데이터 베이스가 될 수 있음)

    - 데이터 베이스 조건

         - 실시간 접근성

         - 지속적인 변화 반영(=최신의 정보가 정확하게 저장)

         - 동시공유

2. RDBMS(Relational DataBase Management System, 관계형 데이터 베이스 관리 시스템)
    - 데이터가 **column(열)**과 **row(행)** 으로 이루어진 테이블에 저장되며 테이블들 사이에 관계를 설정하여 관리하는 소프트웨어 또는 시스템을 의미
    - RDBMS 제품의 종류

         - Oracle사의 Oracle, MS사의 MS-SQL, Sun Microsystemtkdml MySQL...

    - 고객의 정보를 저장하는 테이블 customer가 있다면 아래와 같은 구조로 데이터를 저장하여 관리함

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e906f00a-80a5-4bab-abfc-70c9cb8ce454/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e906f00a-80a5-4bab-abfc-70c9cb8ce454/Untitled.png)

3. SQL(Structured Query Language)
    - RDBMS에 접근해서 데이터의 입력, 수정, 삭제, 검색하는 등의 기능을 가진 RDBMS 관리 언어

        → 검색이 가장 중요함

    - 특징

         - 절차적 언어가 아닌 **구조적 언어**

        <참고> 절차적 언어(procedural Language)

        : 모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어, C, Java 등)

        <참고> 구조적 언어(structured Language)

        : 처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 그에 맞게 조건들만 나열하면 로직이 처리되는 언어

    - SQL 구문의 종류

        **DDL(Data Definition Language = 데이터 정의 언어)**

         - 객체를 생성, 수정, 삭제 등의 작업을 함

        **CREATE** : 객체 생성

        **ALTER** : 객체 수정

        (alter : 바꾸다)

        <주의> alter는 update가 아님

        **DROP** : 객체 삭제

        기타 등등

        <주의> 오라클에서 **객체**란?

        → 이름을 가지고 저장되는 것들을 객체라 부름 (자바의 객체와 다름)

        데이터는 객체가 아님, 데이터를 저장하고 있는 테이블이 객체

        <참고> 오라클에서 객체는 **테이블, 뷰, 트리거, index** 등을 말함

        **DML(Data Manipulation Language = 데이터 처리 언어)**

         - 테이블 안의 데이터를 입력, 수정, 삭제, 검색 등의 작업을 함

        **INSERT** : 행 단위의 데이터 입력 (입력은 행 단위로만 가능)

        **UPDATE** : 셀 단위의 데이터 수정/삭제 (셀에다가 데이터를 입력할 수 있는 것은 없음)

        **DELETE** : 행 단위의 데이터 삭제

        **SELECT** : n행 m열의 데이터 검색 (DB 실력은 SELECT 구사 능력임)

        <문제> 셀에 있는 데이터를 제거하는 SQL 구문 : **UPDATE** 

        <문제> 행에 있는 데이터를 제거하는 SQL 구문 : **DELETE**

        **DCL(Data Control Language = 데이터 제어 언어)**

        **COMMIT** : 트렌잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정

        **ROLLBACK** : 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소

        **GRANT** : 접근 제어, 작업 권한 허용(부여)

        **REVOKE** : 권한 제거(취소) 

4. 트랜잭션(Transaction)

     - 모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위

     - 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산

     - 트랜잭션은 주로 입력, 수정, 삭제 SQL 구문 실행 시 설정(SELECT 제외)

    두개 이상의 입력, 수정, 삭제 구문(INSERT, UPDATE, DELETE) 구문 등등일 경우 트랜잭션을 걸면 좋음

     - 트랜잭션을 걸지 않으면 영속성 컨텍스트의 장점(1차 캐시, 더티 체킹, Write Behind 등)을 누릴 수 없음

     - Transaction 작업의 마지막은 무조건 **COMMIT/ROLLBACK**

     → 데이터를 입력한 다음 COMMIT을 하지 않으면 데이터가 저장되지 않음

    COMMIT/ROLLBACK을 하기 전 작업은 단지 가상작업일 뿐

     - 트랜잭션이 걸린 작업은 **가상 작업**이 되고 **ROLLBACK**을 실행하면 모두 취소되고 **COMMIT**을 실행하면 가상 작업이 모두 실제 작업으로 인정됨

     - 트랜잭션 하기 전(COMMIT/ROLLBACK)에 컴퓨터가 꺼지면 자동으로 ROLLBACK시킴

    <주의> 트랜잭션은 의도를 가지고 설정하는 것

    <주의> 트랜잭션이 없는 작업은 n가지 이상의 다양한 결과로 진행될 수 있음

5. 오라클에서 계정이란?

    : 오라클에 접속하는 사용자를 말함

     - 사용자마다 권한을 다르게 줄 수 있음

     - 오라클은 다수의 클라이언트에게 동시에 정보를 제공하는 서버이므로 서버의 특징인 계정과 암호를 가지고 있음

    <참고> 서버(SERVER) : 다수의 클라이언트에게 동시에 정보를 제공하는 하드웨어(HW)나 소프트웨어(SW)를 말함

    - ID와 계정의 차이

         - id : 들어갔을 때 모두 똑같은 기능, 환경을 누릴 수 있음

         - 계정 : 갖고 있는 권한별로 할 수 있는 것이 다름

    - 오라클 계정의 종류

        **SYS**

        : 오라클 설치 시 기본적으로 만들어지는 계정, 모든 것을 할 수 있음, 조심스럽게 관리해야 함
        (최고의 권한)

        **SYSTEM**

        : 오라클 설치 시 기본적으로 만들어지는 계정, 모든 것을 할 수 있음, 단 데이터베이스 생성 권한이 없음

        **SCOTT**

        : 오라클 설치 시 기본적으로 만들어지는 계정, 권한이 거의 없음

         **생성계정**

        : 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정됨

        오라클의 default 계정 : SYS, SYSTEM, SCOTT

6. 데이터베이스 차원에서 **스키마(Schema, 도식)**란? 

     - 데이터 베이스의 구조에 대한 정의와 제약조건 등을 기술한 **명세서**

     - 계정이 생성한 모든 **객체**들을 의미(오라클 객체 ⇒ 테이블, 뷰, 인덱스, 프로시저, 트리거 등)

     객체들이 DB구조에 대한 정의와 이에 대한 제약조건 등을 기술한 명세서이기 때문

    <예> kim계정이 객체(테이블, 인덱스, 뷰 등)들을 생성했다면 이 객체들을 모두 가리켜 kim스키마라고 함

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abf1dbd5-45c6-4f23-8ca4-fde55e171f91/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abf1dbd5-45c6-4f23-8ca4-fde55e171f91/Untitled.png)

    → 같은 계정에서 똑같은 이름의 테이블을 생성할 수 없음

7. 데이터 베이스 차원에서 테이블(Table)이란?

     - RDBMS에서 데이터가 실질적으로 저장되는 **논리적 장소**를 말함

     - 열(column)과 행(row)으로 구성

     - 테이블은 이름을 가지고 저장되는 객체의 한 종류

     - 개발자 입장에서 제일 손이 많이 가는 객체

    테이블에 데이터를 입력하는 SQL 구문 : INSERT
    테이블에 데이터를 수정하는 SQL 구문 : UPDATE
    테이블에 데이터를 삭제하는 SQL 구문 : DELETE
    테이블에 데이터를 검색하는 SQL 구문 : SELECT

8. 테이블(Table)을 생성하는 SQL구문의 형식은?

    ```sql
    CREATE TABLE 테이블명(
    	컬럼명1 자료형 제약조건
    	, 컬럼명2 자료형 제약조건
    	, ~
    	, 컬럼명n 자료형 제약조건
    )
    -- : 주석처리
    ```

     - column : 이론적으로는 하나 이상, 실질적으로는 두개 이상

     - 자료형(Data Type) : 테이블의 컬럼에 입력될 데이터의 유형을 말함. 문자형, 숫자형, 날짜형 등이 있음

    <참고> 자바의 데이터 종류

    - 기본형 : byte, short, int, long, float, double, char, boolean
    - 참조형 : 객체의 메모리 위치 주소값을 말함

        → 객체에 접근해서 객체가 가지고 있는 속성변수나 메서드를 호출

        ```sql
        StringBuffer sb= new StringBuffer(); // 다량의 문자 데이터 보관
        	// StringBuffer객체를 생성해서 sb안에 넣음
        sb.append("성이현");
        sb.append("민채홍");
        ```

        ```sql
        String name1 = "손오공"; // 문자열 : String 객체의 name -> 참조형
        char name2 = "손" // 문자형 : char -> 기본형
        ```

     - 제약조건 : 테이블 생성 시 입력되는 데이터의 입력 가능 조건을 말함. 제약 조건에 위배되는 데이터는 삽입될 수 없음(한 행이 다 들어가지 않음), 제약조건이 생략되면 데이터가 입력되지 않을 경우 null이 저장됨

    → 들어오는 데이터의 점검

    <문제> 테이블이 주어지고 데이터가 순서대로 입력될 때 입력가능한 데이터와 불가능한 데이터의 이유 찾기

    <주의> 테이블명, 컬럼명 제작 규칙

     - 영문자 1~9, $, #, _로 구성되고 반드시 영문자로 시작해야함
     - 30자를 초과할 수 없음, SQL예약어는 사용할 수 없음
     - 하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야 함
     - 테이블명, 컬럼명은 가독성있게 주는 것이 제일 중요
     - 테이블명, 컬럼명, 제약조건명을 "로 감싸거나 "없이 그냥 써도 됨

9. 오라클 테이블 자료형의 종류

     - 오라클의 자료형은 넉넉하게 줌(예 -  VARCHAR(200)  )

    **문자형**

    - **CHAR(s)**

        : 고정길이 문자열 저장(항상 길이가 똑같은 데이터), s는 byte 수를 의미

         - 설정크기보다 입력문자 크기가 작으면(모자라게 들어가면) 공백으로 남겨둠(공백도 데이터) : 최대 단점

         - 고객 요구사항이 바뀌면 자료형을 또 바꿔야함 : 단점

         - 오라클의 부하를 덜어줌 : 최대 장점

         - 설정 크기보다 입력 무자 크기가 크면 행 자체가 입력되지 않음

         - 실질적으로 많이 사용하지 않음

         - 최대 크기는 2000byte 까지

         - CHAR는 CHAR(1)과 동일 → 성별을 영어로 표현하는 경우 사용될 수 있음

        <예> CHAR(4) : 문자 4byte까지 입력 가능, 즉 영문 4개까지, 한글 2개까지 가능

        만약 영어 5글자가 들어오면 데이터 들어갈 수 없음

        만약 영어 3글자가 들어오면 나머지는 공백으로 들어감

        <참고> 영문 1자는 1byte차지, 한글 1자는 2byte 차지

    - **VARCHAR2(s)**

        : 가변길이 문자열 저장(길이가 변하는 데이터), s는 byte 수를 의미

         - 설정 크기보다 입력 문자 크기가 작으면 크기가 자동으로 줄어듬 : 장점

         - DB 서버 부담은 증가 : 단점

         - 설정 크기보다 입력문자 크기가 크면 행 자체가 입력되지 않음

         - 보통 테이블을 설계할 때는 CHAR타입보다는 VARCHAR2 타입을 많이 사용

        임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문

         - 개발과정에서는 데이터의 크기 자체를 넉넉하게 잡아주는 것이 좋음

         - 최대 크기는 4000byte 까지

         - VARCHAR2만 쓸 수 없음

        <예> VARCHAR2(4): 문자 4byte까지 입력 가능. 즉 영문 4개까지, 한글 2개까지 가능

    **숫자형**

    - **NUMBER(p, s)**

         - 정수형 또는 실수형 숫자 저장

         - p(precision) : 정수+소숫점 이하 → 전체 자릿수(1~38)

        s(scale) : 소숫점 이하 자릿수(-84~127)

         - s 생략시 default 0 설정

         - NUMBER(p, s 모두 생략 시)는 정수, 소숫점 이하 자릿수 합쳐서 40자리까지 저장

         - 소수점 자리수가 넘치면 반올림하고 정수 자리수가 넘치면 오류 발생(행 자체가 들어가지 않음)

        <예> 실수

        NUMBER(6, 2)라고 지정한 컬럼에 1234.56을 저장하면 → 1234.56 저장

        NUMBER(6, 2)라고 지정한 컬럼에 1234.567을 저장하면 → 1234.57 저장

        (반올림 한 후 소수점 2자리까지 저장)

        NUMBER(6,2)라고 한 컬럼에 12345.6을 저장하면 → 저장 오류(행 자체가 들어갈 수 없음). 정수 자릿수 부족으로 오류

        (정수가 넘치기 때문에 데이터가 들어갈 수 없음)

        <예> 정수

        NUMBER(3)라고 지정한 컬럼에 123 저장하면? → 123 저장 

        (0~999들어갈 수 있음)

        NUMBER(3)라고 지정한 컬럼에 123.4 저장하면? → 123 저장 

        (소수점 1자리에서 반올림해서 저장)

        NUMBER(3)라고 지정한 컬럼에 1234 저장하면? → 저장 오류(행 자체가 들어갈 수 없음). 정수 자릿수 부족으로 오류 

        <참고> number(6, -2)

        : 100의 자리수까지 반올림

        scale이 음수일 때는 소수점의 왼쪽에 있는 자릿수, 최하위 유효자릿수를 포함하지 않음

    **날짜형**

    - **DATE**

         - [년, 월, 일, 시, 분, 초] 저장

         - 저장 범위는 BC 4712년 1월 1일 ~ 9999년 12월 31일

        <참고> 보통 날짜형 데이터는 SQL 문장에서 
        **TO_CHAR**(날짜 자료형 → 문자형, 내가 원하는 대로 출력)
        **TO_DATE**(날짜 문자형 → 날짜 자료형, 날짜 계산 가능)
        변환함수와 같이 사용됨

        <예> 크리스마스까지 남은 기간 검색하는 SQL 구문 작성

        ```sql
        SELECT TO_DATE('20211225','YYYYMMDD')-TO_DATE('20210611','YYYYMMDD') FROM DUAL 
        ```

        <예> 오늘 날짜를 년-월-일로 검색하는 SQL 구문 작성

        ```sql
        SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL
        ```

        <참고> 변환함수는 **TO_CHAR, TO_DATE, TO_NUMBER와 같이 사용됨**

      - CHAR & VARCHAR2의 차이

    CHAR : 항상 길이가 일정하게 들어오는 데이터

    입력 수가 작으면 공백으로 남기 때문에 이론적으로 주민등록 번호에 사용 **CHAR(13)**

    → 실질적으로 넉넉하게 **VARCHAR2(20)** 사용

    VARCHAR2 : 길이가 변할 수 있는 데이터

     - 문자형과 숫자형을 결정하는 기준

    : 연산이 필요하면 숫자형, 연산을 하지 않으면 문자형

    → 정확히 모르겠으면 문자형으로! (숫자형으로 바꾸는 함수가 있기 때문)

    <예> 고객 번호를 숫자형으로 쓰는 이유

    : 1씩 증가하기 때문에 고객번호는 숫자형으로 사용함

     - 테이블에 행 단위의 데이터가 못 들어가는 이유

    : 자료형에 위배되거나, 제약조건에 위배되었을 경우(행으로 데이터가 들어가기 위해서 자료형과 제약조건을 만족해야 함)

    <참고>

    기타 문자형 CLOB, LONG, NCHAR(s), NVARCHAR(s), NCLOB 등이 있음
    기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE도 있음
    기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있음

10. 오라클에서 제약 조건의 종류

     → 제약조건을 무조건 줘야하는 것은 아님, 필요에 의해서 주어짐

    - **not null**

         : 반드시 데이터가 입력되어야 함, 비어있으면 안됨, 필수 입력 데이터

    - **unique**

        : 중복되는 데이터는 입력 불가능, 중복되면 안됨

        <예> 직원번호, 주민등록번호, 전화번호 등등
        일반적으로, 실무적으로, 관용적으로 unique를 가진 컬럼은 대부분 not null도 같이 들어감
        → 절대 규칙은 아님

         - not null이라고 무조건 unique가 들어가지는 않음

    - **default**

         : 데이터를 입력하지 않으면 디폴트로 설정한 값이 입력됨

        <예> 회원가입할 때 가입날짜를 입력하지 않아도 그 당일 날짜가 저장되는 경우

         - default가 걸려있으면 대부분 not null을 쓴 효과와 비슷함

    - **check**

         : 지정한 데이터만 입력 가능

        <예> 성별 입력 시 남 또는 여만 입력되는 경우

    - **primary key(PK, 주 식별자) 필수!**

         : not null, unique의 제약조건 성질을 가짐, 즉 행과 행을 구분할 수 있는 유일한 데이터가 입력됨(중복 불가, 비어있으면 안됨)

         - 차후에 foreign key에 의해 참조당할 수도 있는 키

         - 하나의 테이블에 하나의 primary key만 설정할 수 있음, 즉 테이블당 0~1개만 줄 수 있음

         - 테이블 당 PK는 하나만 정의 가능하며, 유일하게 식별할 수 있는 컬럼, 고유 인덱스 생성됨

         - '기본키', '주 키'라고도 함

    - **foreign key(FK, 외부 식별자) 필수!**

        : primary key에 존재하는 데이터만 삽입될 수 있음(=primary key를 참조하는 키)

         - 자식 테이블에 설정(반대로 참조되는 테이블이 부모 테이블, 부모 테이블은 삭제가 불가능해짐)

         - 테이블 당 FK는 0개 이상, 참조하는 PK가 동일한 테이블에 있을 수 있음

         <주의> 예외적으로 null값이 들어갈 수 있음, 즉 데이터가 입력되지 않을 수도 있음

         - FK를 주는 이유 : 존재하지 않는 데이터(유령 데이터)를 들어오지 못하게 하기 위해(정확성과 일관성을 유지)

         - table과 table간의 관계를 설정하는 키

        테이블끼리의 관계를 맺는 제약조건 : FK(Foreign Key)

         - '참조키', '외래키', '관계키', '종속키'라고도 함

         - FK가 있으면 반드시 PK가 있어야 함(PK가 있다고 FK가 반드시 있어야 하는 것은 아님)

        PK가 없으면 FK도 없음

        참조 당하는 PK가 먼저 생성되어야 함

         ⇒ 관계형 데이터 베이스 : 테이블끼리 관계가 맺어짐

        <예> 

        ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a33e2fd-44c5-499c-8072-dc4061670759/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4a33e2fd-44c5-499c-8072-dc4061670759/Untitled.png)

         - dept 테이블이 가장 먼저 생성되어야 함→ employee → customer

         - 삭제는 customer가 먼저!

         - dept의 10번 행은 삭제할 수 없음 : 밑에 테이블에서 참조하고 있기 때문에

        50번 행은 삭제 가능 : 밑에 테이블에서 참조하고 있지 않기 때문에

         - 만약 dept의 10번 행을 삭제하려면 customer의 3번 행 삭제 후 employee의 1번 행 삭제 후 dept의 10번 행을 삭제해야 함

11. 시퀀스(sequence)란?

     - 고유 일련번호를 생성해서 제공하는 객체, 일종의 **일련 번호 생성기**

     - 주로 하나의 테이블에서 Primary Key로 지정된 컬럼명에 입력될 **일련 번호** 값을 생성함

    <비유> 은행에서 번호표 뽑는 기계와 동일한 기능을 가짐

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1b7b0f6-9f7f-4c1f-8737-b8fcc88d7f16/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c1b7b0f6-9f7f-4c1f-8737-b8fcc88d7f16/Untitled.png)

    - 증가된 새 일련번호 얻는 SQL 구문

         - `시퀀스명.nextval`

    - 마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문

         - `시퀀스명.currval`

    - 시퀀스 삭제 SQL 구문

         - `drop sequence 시퀀스명`

12. 오라클을 연습하려면 어떤 SW를 설치해야하는가?

    ① 개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
    ② 오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다.
    ③ Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다.
    ▶ IP => localhost
    ▶ 사용자 => system
    ▶ 암호 => 설정암호
    ▶ SID(서비스명) => XE

13. system 계정으로 접속하는 쓸데없는 테이블이 많아 번거로울 때, system 계정과 동일한 권한을 가지는 새로운 계정을 만드려면?

    ① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
    `create user king identified by k123;`
    ② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
    `grant connect,resource,dba to king;`
    ③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다,
    ▶ IP => 127.0.0.1 또는 localhost
    ▶ 사용자 => king
    ▶ 암호 => k123
    ▶ SID(서비스명) => XE

    - 계정 생성하기

        `create user king identified by k123;`

        → king 계정 만들고 비밀번호 k123

    - 권한 부여하기

        `grant connect,resource,dba to king;`
