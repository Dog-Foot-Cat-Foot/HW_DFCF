package day0727.ch12;

import java.util.LinkedList;

public class Ex04_LinkedListTest {

	public static void main(String[] args) {
		
		//------------------------------------------
		// <1> String형으로 LinkedList 변수 myList 선언, 
		//	String형으로 LinkedList 인스턴스 생성 후 리턴된 메위주 대입
		// <2> myList로 add() 메서드 호출하여 "A" 요소 추가
		// <3> myList로 add() 메서드 호출하여 "B" 요소 추가
		// <4> myList로 add() 메서드 호출하여 "C" 요소 추가
		// <5> myList 데이터 출력, [A, B, C]
		//------------------------------------------
		LinkedList<String> myList = new LinkedList<String>();	// <1>
		
		myList.add("A");				// <2>
		myList.add("B");				// <3>
		myList.add("C");				// <4>
		
		System.out.println(myList);		// <5>
		
		//------------------------------------------
		// <1> myList로 add() 메서드 호출하여 1번째에 "D" 요소 추가
		// <2> myList 데이터 출력, [A, D, B, C]
		// <3> myList로 add() 메서드 호출하여 "0" 요소 추가
		// <4> myList 데이터 출력, [A, D, B, C, 0]
		//------------------------------------------
		myList.add(1, "D");				// <1>
		System.out.println(myList);		// <2>
		
		myList.add("0");				// <3>
		System.out.println(myList);		// <4>
		
		//------------------------------------------
		// <1> myList로 removeList() 메서드 호출하여 마지막 요소 삭제후 해당 요소 출력, 0
		// <2> myList 데이터 출력, [A, D, B, C]
		//------------------------------------------
		System.out.println(myList.removeLast());	// <1>
		System.out.println(myList);					// <2>
		
		
		/* =========================================
		 * LinkedList 클래스
		 * 링크드 리스트의 각 요소는 다음 요소를 가리키는 주소 값을 가진다.
		 * 물리적인 메모리는 떨어져 있어도 논리적으로는 앞 뒤 순서가 있다.
		 * 장점: ArrayList에 비해 중간에 자료를 넣고 제거하는데 시간이 적게 걸린다.
		 * 		크기를 동적으로 증가시킬 수 있다.
		 * 각 요소는 요소의 자료와 다음 요소의 주소를 저장하는 부분으로 구현된다.
		 * 마지막 요소는 널(null)이나 0을 저장한다.
		 * 요소 추가/삭제 시 서로 가리키고 있는 주소 값만 변경해 주면 된다.
		 * 제거된 메모리는 나중에 자바의 가비지 컬렉터에 의해 수거된다.
		 * 
		 * 배열과 링크드 리스트의 다른 점
		 * 배열은 생성할 때 용량 지정, 용량보다 더 많은 요소가 추가된 경우 용량을 늘려 가며 수행
		 * 링크드 리스트는 요소를 추가할 때마다 동적으로 요소의 메모리를 생성하기 때문에 
		 * 	배열처럼 용량을 늘리고 요소 값을 복사하는 번거로움이 없다.
		 * 어떤 요소의 위치(i번째)를 찾을 때 
		 * 	배열은 물리적으로 연결되 자료 구조이므로 i번째 요소 메모리 위치를 바로 계산할 수 있다
		 * 배열이 링크드 리스트보다 구현하기도 쉽다. 
		 * 정리하면,
		 * 	사용하는 자료의 변동(삽입/삭졔)이 많은 경우에는 링크드 리스트를, 
		 * 	자료 변동이 거의 없는 경우에는 배열을 사용하는 것이 효율적이다.
		 * =========================================
		 */

	}

}
